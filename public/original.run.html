
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Original Code Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="code.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="part1/finger_thinking.html">
            
                <a href="part1/finger_thinking.html">
            
                    
                    Part 1: Finger Thinking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="part1/lesson0.run.html">
            
                <a href="part1/lesson0.run.html">
            
                    
                    Setup
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="part1/lesson1.run.html">
            
                <a href="part1/lesson1.run.html">
            
                    
                    Lesson 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="part1/lesson2.run.html">
            
                <a href="part1/lesson2.run.html">
            
                    
                    Lesson 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="part1/lesson3.run.html">
            
                <a href="part1/lesson3.run.html">
            
                    
                    Lesson 3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="part1/lesson4.run.html">
            
                <a href="part1/lesson4.run.html">
            
                    
                    Lesson 4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="part1/lesson5.run.html">
            
                <a href="part1/lesson5.run.html">
            
                    
                    Lesson 5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="part1/lesson6.run.html">
            
                <a href="part1/lesson6.run.html">
            
                    
                    Lesson 6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="part1/lesson7.run.html">
            
                <a href="part1/lesson7.run.html">
            
                    
                    Lesson 7
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="part1/lesson8.run.html">
            
                <a href="part1/lesson8.run.html">
            
                    
                    Lesson 8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="part1/lesson9.run.html">
            
                <a href="part1/lesson9.run.html">
            
                    
                    Lesson 9
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="part1/lesson10.run.html">
            
                <a href="part1/lesson10.run.html">
            
                    
                    Lesson 10
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="part1/lesson11.run.html">
            
                <a href="part1/lesson11.run.html">
            
                    
                    Lesson 11
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.13" data-path="part1/recap.html">
            
                <a href="part1/recap.html">
            
                    
                    Recapitulation
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="part2/ducks_in_a_row.html">
            
                <a href="part2/ducks_in_a_row.html">
            
                    
                    Part 2: Ducks in a Row
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="part2/lesson0.run.html">
            
                <a href="part2/lesson0.run.html">
            
                    
                    Setup
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="part2/lesson1.run.html">
            
                <a href="part2/lesson1.run.html">
            
                    
                    Lesson 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="part2/lesson2.run.html">
            
                <a href="part2/lesson2.run.html">
            
                    
                    Lesson 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="part2/lesson3.run.html">
            
                <a href="part2/lesson3.run.html">
            
                    
                    Lesson 3
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="wax_on_wax_off.html">
            
                <a href="wax_on_wax_off.html">
            
                    
                    Part 3: Wax On, Wax Off
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="going_public.html">
            
                <a href="going_public.html">
            
                    
                    Part 4: Going Public
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="code.html">
            
                <a href="code.html">
            
                    
                    Code Listings
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.6.1" data-path="original.run.html">
            
                <a href="original.run.html">
            
                    
                    Original Code
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Original Code</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="original-code">Original Code</h1>
<p>In <a href="finger_thinking.html">the intro to Part 1</a> I mentioned that I doodle in a thrwaway python file. Well, here is one I did
not throw away, which turned into the seed for the code in this book.</p>
<p>The code has not been improved in any way other than format it
via <a href="https://github.com/ambv/black" target="_blank">black</a>.</p>
<p>It has comments written as &quot;we&quot; because it was meant to be a blog post, and then it grew.</p>
<p>The code in the book is a lightly cleaned up version of this.</p>
<pre><code class="lang-python"><span class="hljs-comment"># original.py</span>
<span class="hljs-keyword">import</span> svgwrite


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span><span class="hljs-params">()</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(
        self,
        x=<span class="hljs-number">0</span>,
        y=<span class="hljs-number">0</span>,
        w=<span class="hljs-number">1</span>,
        h=<span class="hljs-number">1</span>,
        red=False,
        blue=False,
        yellow=False,
        letter=None,
    )</span>:</span>
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.red = red
        self.blue = blue
        self.yellow = yellow
        self.letter = letter

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.letter <span class="hljs-keyword">or</span> <span class="hljs-string">&apos;Box&apos;</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.letter <span class="hljs-keyword">or</span> <span class="hljs-string">&apos;Box&apos;</span>


big_box = Box(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">80</span>, <span class="hljs-number">1000</span>)
pages = [big_box]


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_boxes</span><span class="hljs-params">(boxes, with_boxes=True)</span>:</span>
    STYLES = <span class="hljs-string">&quot;&quot;&quot;
    .red { fill: red;}
    .green { fill: green;}
    .blue {fill: blue;}
    .yellow {fill: yellow;}
    .bigbox {fill: cyan; }
    &quot;&quot;&quot;</span>
    dwg = svgwrite.Drawing(
        <span class="hljs-string">&apos;test.svg&apos;</span>,
        profile=<span class="hljs-string">&apos;full&apos;</span>,
        size=(<span class="hljs-string">&apos;%d&apos;</span> % big_box.w, <span class="hljs-string">&apos;%d&apos;</span> % big_box.w),
    )
    dwg.defs.add(dwg.style(STYLES))
    <span class="hljs-keyword">for</span> bb <span class="hljs-keyword">in</span> pages:
        dwg.add(
            dwg.rect(
                insert=(bb.x, bb.y), size=(bb.w, bb.h), class_=<span class="hljs-string">&apos;bigbox&apos;</span>
            )
        )
    <span class="hljs-keyword">for</span> box <span class="hljs-keyword">in</span> boxes:
        <span class="hljs-keyword">if</span> with_boxes:
            <span class="hljs-keyword">if</span> box.red:
                dwg.add(
                    dwg.rect(
                        insert=(box.x, box.y),
                        size=(box.w, box.h),
                        class_=<span class="hljs-string">&apos;red&apos;</span>,
                    )
                )
            <span class="hljs-keyword">elif</span> box.blue:
                dwg.add(
                    dwg.rect(
                        insert=(box.x, box.y),
                        size=(box.w, box.h),
                        class_=<span class="hljs-string">&apos;blue&apos;</span>,
                    )
                )
            <span class="hljs-keyword">elif</span> box.yellow:
                dwg.add(
                    dwg.rect(
                        insert=(box.x, box.y),
                        size=(box.w, box.h),
                        class_=<span class="hljs-string">&apos;yellow&apos;</span>,
                    )
                )
            <span class="hljs-keyword">else</span>:
                dwg.add(
                    dwg.rect(
                        insert=(box.x, box.y),
                        size=(box.w, box.h),
                        class_=<span class="hljs-string">&apos;green&apos;</span>,
                    )
                )
        <span class="hljs-keyword">if</span> box.letter:
            dwg.add(
                dwg.text(
                    box.letter,
                    insert=(box.x, box.y + box.h),
                    font_size=box.h,
                    font_family=<span class="hljs-string">&apos;Arial&apos;</span>,
                )
            )
    dwg.save()


<span class="hljs-comment"># So, how could we layout the many boxes inside the big_box?</span>
many_boxes = [Box(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">5000</span>)]

<span class="hljs-comment"># Do nothing ...</span>
<span class="hljs-comment"># They are all in the same place</span>
<span class="hljs-comment"># draw_boxes(many_boxes)</span>

<span class="hljs-comment"># Try to lay them out side by side</span>
<span class="hljs-comment"># They just go too wide</span>
<span class="hljs-comment"># We add a &quot;separation&quot; constant so you can see the boxes individually</span>
separation = <span class="hljs-number">.2</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout1</span><span class="hljs-params">(boxes)</span>:</span>
    <span class="hljs-keyword">for</span> i, box <span class="hljs-keyword">in</span> enumerate(boxes):
        box.x = i * (<span class="hljs-number">1</span> + separation)


<span class="hljs-comment"># Put each one next to the other until they reach a width,</span>
<span class="hljs-comment"># then go down. This is a monospaced layout.</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout2</span><span class="hljs-params">(boxes)</span>:</span>
    <span class="hljs-keyword">for</span> i, box <span class="hljs-keyword">in</span> enumerate(boxes[<span class="hljs-number">1</span>:]):
        box.x = boxes[i - <span class="hljs-number">1</span>].x + <span class="hljs-number">1</span> + separation
        box.y = boxes[i - <span class="hljs-number">1</span>].y
        <span class="hljs-keyword">if</span> box.x &gt; big_box.w:
            box.x = <span class="hljs-number">0</span>
            box.y = boxes[i - <span class="hljs-number">1</span>].y + <span class="hljs-number">1.1</span>


<span class="hljs-comment"># Now, what happens if some boxes are wider than the others?</span>
<span class="hljs-comment"># layout2 will make them overlap or have wide breaks between them</span>
<span class="hljs-keyword">import</span> random

many_boxes = [
    Box(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span> + random.randint(<span class="hljs-number">-2</span>, <span class="hljs-number">2</span>) / <span class="hljs-number">10</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">5000</span>)
]

<span class="hljs-comment"># So, we use each box&apos;s width instead of a fixed width</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout3</span><span class="hljs-params">(boxes)</span>:</span>
    <span class="hljs-keyword">for</span> i, box <span class="hljs-keyword">in</span> enumerate(boxes[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
        prev_box = boxes[i - <span class="hljs-number">1</span>]
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        <span class="hljs-keyword">if</span> box.x &gt; big_box.w:
            box.x = <span class="hljs-number">0</span>
            box.y = prev_box.y + <span class="hljs-number">1.1</span>


<span class="hljs-comment"># layout3(many_boxes)</span>
<span class="hljs-comment"># But the right side is ragged</span>

<span class="hljs-comment"># We can, when we break, put the remaining space spread between boxes</span>
<span class="hljs-comment"># This is a &quot;justified&quot; layout</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout4</span><span class="hljs-params">(boxes)</span>:</span>
    last_break = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i, box <span class="hljs-keyword">in</span> enumerate(boxes[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
        prev_box = boxes[i - <span class="hljs-number">1</span>]
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        <span class="hljs-keyword">if</span> box.x &gt; big_box.w:
            box.x = <span class="hljs-number">0</span>
            box.y = prev_box.y + <span class="hljs-number">1.1</span>
            slack = big_box.w - (prev_box.x + prev_box.w)
            mini_slack = slack / (i - last_break)
            <span class="hljs-keyword">for</span> j, b <span class="hljs-keyword">in</span> enumerate(boxes[last_break:i]):
                b.x += j * mini_slack
            last_break = i


<span class="hljs-comment"># layout4(many_boxes)</span>

<span class="hljs-comment"># But what happens if some boxes are red?</span>
<span class="hljs-keyword">for</span> box <span class="hljs-keyword">in</span> many_boxes:
    <span class="hljs-keyword">if</span> random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>) &gt; <span class="hljs-number">5</span>:
        box.red = <span class="hljs-keyword">True</span>
<span class="hljs-comment"># Well, nothing much, other than they are red</span>

<span class="hljs-comment"># But what if red means &quot;stretchy&quot; and only those can stretch?</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout5</span><span class="hljs-params">(boxes)</span>:</span>
    last_break = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i, box <span class="hljs-keyword">in</span> enumerate(boxes[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
        prev_box = boxes[i - <span class="hljs-number">1</span>]
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        <span class="hljs-keyword">if</span> box.x &gt; big_box.w:
            box.x = <span class="hljs-number">0</span>
            box.y = prev_box.y + <span class="hljs-number">1.1</span>
            slack = big_box.w - (prev_box.x + prev_box.w)
            row = boxes[last_break:i]
            reds = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> row <span class="hljs-keyword">if</span> b.red]
            <span class="hljs-comment"># sometimes there is no red in the row. Do nothing.</span>
            <span class="hljs-keyword">if</span> reds:
                mini_slack = slack / len(reds)
                <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> reds:
                    b.w += mini_slack
                <span class="hljs-keyword">for</span> j, b <span class="hljs-keyword">in</span> enumerate(row[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
                    b.x = row[j - <span class="hljs-number">1</span>].x + row[j - <span class="hljs-number">1</span>].w + separation
            last_break = i


<span class="hljs-comment"># But what happens if a few are blue?</span>
<span class="hljs-keyword">for</span> box <span class="hljs-keyword">in</span> many_boxes:
    <span class="hljs-keyword">if</span> random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">150</span>) &gt; <span class="hljs-number">149</span>:
        box.blue = <span class="hljs-keyword">True</span>

<span class="hljs-comment"># Well, nothing much, other than they are blue</span>

<span class="hljs-comment"># But what if blue means &quot;this row ends here&quot;?</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout6</span><span class="hljs-params">(boxes)</span>:</span>
    last_break = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i, box <span class="hljs-keyword">in</span> enumerate(boxes[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
        prev_box = boxes[i - <span class="hljs-number">1</span>]
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        <span class="hljs-keyword">if</span> prev_box.blue <span class="hljs-keyword">or</span> box.x &gt; big_box.w:
            box.x = <span class="hljs-number">0</span>
            box.y = prev_box.y + <span class="hljs-number">1.1</span>
            slack = big_box.w - (prev_box.x + prev_box.w)
            row = boxes[last_break:i]
            reds = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> row <span class="hljs-keyword">if</span> b.red]
            <span class="hljs-comment"># sometimes there is no red in the row. Do nothing.</span>
            <span class="hljs-keyword">if</span> reds:
                mini_slack = slack / len(reds)
                <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> reds:
                    b.w += mini_slack
                <span class="hljs-keyword">for</span> j, b <span class="hljs-keyword">in</span> enumerate(row[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
                    b.x = row[j - <span class="hljs-number">1</span>].x + row[j - <span class="hljs-number">1</span>].w + separation
            last_break = i


<span class="hljs-comment"># Some reds get reeeeeeealy stretchy! That is because rows that</span>
<span class="hljs-comment"># end because of a blue have very few boxes. So maybe we don&apos;t stretch those?</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout7</span><span class="hljs-params">(boxes)</span>:</span>
    last_break = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i, box <span class="hljs-keyword">in</span> enumerate(boxes[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
        prev_box = boxes[i - <span class="hljs-number">1</span>]
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        <span class="hljs-keyword">if</span> prev_box.blue <span class="hljs-keyword">or</span> box.x &gt; big_box.w:
            box.x = <span class="hljs-number">0</span>
            box.y = prev_box.y + <span class="hljs-number">1.1</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> prev_box.blue:
                row = boxes[last_break:i]
                slack = big_box.w - (row[<span class="hljs-number">-1</span>].x + row[<span class="hljs-number">-1</span>].w)
                reds = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> row <span class="hljs-keyword">if</span> b.red]
                <span class="hljs-comment"># sometimes there is no red in the row. Do nothing.</span>
                <span class="hljs-keyword">if</span> reds:
                    mini_slack = slack / len(reds)
                    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> reds:
                        b.w += mini_slack
                    <span class="hljs-keyword">for</span> j, b <span class="hljs-keyword">in</span> enumerate(row[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
                        b.x = row[j - <span class="hljs-number">1</span>].x + row[j - <span class="hljs-number">1</span>].w + separation
            last_break = i


<span class="hljs-comment"># What if we want blue boxes break lines but also separate lines a little?</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout8</span><span class="hljs-params">(boxes)</span>:</span>
    last_break = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i, box <span class="hljs-keyword">in</span> enumerate(boxes[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
        prev_box = boxes[i - <span class="hljs-number">1</span>]
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        <span class="hljs-keyword">if</span> prev_box.blue <span class="hljs-keyword">or</span> box.x &gt; big_box.w:
            box.x = <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> prev_box.blue:
                box.y = prev_box.y + <span class="hljs-number">2.1</span>
            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># not blue</span>
                box.y = prev_box.y + <span class="hljs-number">1.1</span>
                row = boxes[last_break:i]
                slack = big_box.w - (row[<span class="hljs-number">-1</span>].x + row[<span class="hljs-number">-1</span>].w)
                reds = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> row <span class="hljs-keyword">if</span> b.red]
                <span class="hljs-comment"># sometimes there is no red in the row. Do nothing.</span>
                <span class="hljs-keyword">if</span> reds:
                    mini_slack = slack / len(reds)
                    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> reds:
                        b.w += mini_slack
                    <span class="hljs-keyword">for</span> j, b <span class="hljs-keyword">in</span> enumerate(row[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
                        b.x = row[j - <span class="hljs-number">1</span>].x + row[j - <span class="hljs-number">1</span>].w + separation
            last_break = i


<span class="hljs-comment"># So ... what if each box has a letter or a space inside it?</span>
<span class="hljs-keyword">for</span> box <span class="hljs-keyword">in</span> many_boxes:
    <span class="hljs-comment"># More than one space so they appear often</span>
    box.letter = random.choice(<span class="hljs-string">&apos;     abcdefghijklmnopqrstuvwxyz&apos;</span>)

<span class="hljs-comment"># Maybe we should make the box sizes depend on the letter inside it?</span>
<span class="hljs-comment"># This is complicated, sorry</span>
<span class="hljs-keyword">import</span> harfbuzz <span class="hljs-keyword">as</span> hb
<span class="hljs-keyword">import</span> freetype2 <span class="hljs-keyword">as</span> ft


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">adjust_widths_by_letter</span><span class="hljs-params">(boxes)</span>:</span>
    buf = hb.Buffer.create()
    buf.add_str(<span class="hljs-string">&apos;&apos;</span>.join(b.letter <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> boxes))
    buf.guess_segment_properties()
    font_lib = ft.get_default_lib()
    face = font_lib.find_face(<span class="hljs-string">&apos;Arial&apos;</span>)
    face.set_char_size(size=<span class="hljs-number">1</span>, resolution=<span class="hljs-number">64</span>)
    font = hb.Font.ft_create(face)
    hb.shape(font, buf)
    <span class="hljs-comment"># at this point buf.glyph_positions has all the data we need</span>
    <span class="hljs-keyword">for</span> box, position <span class="hljs-keyword">in</span> zip(boxes, buf.glyph_positions):
        box.w = position.x_advance


adjust_widths_by_letter(many_boxes)
<span class="hljs-comment"># layout8(many_boxes)</span>

<span class="hljs-comment"># There is all that space between letters we added when they were boxes. Let&apos;s remove it.</span>

separation = <span class="hljs-number">0</span>
layout8(many_boxes)

<span class="hljs-comment"># How about we get the letters from a text instead of randomly?</span>
p_and_p = open(<span class="hljs-string">&apos;pride-and-prejudice.txt&apos;</span>).read()
text_boxes = []
<span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> p_and_p:
    text_boxes.append(Box(letter=l))
adjust_widths_by_letter(text_boxes)
<span class="hljs-comment"># layout8(text_boxes)</span>
<span class="hljs-comment"># Oh, it&apos;s all green now, and it&apos;s all one thing after another. We should make newlines blue!</span>

<span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> text_boxes:
    <span class="hljs-keyword">if</span> b.letter == <span class="hljs-string">&apos;\n&apos;</span>:
        b.blue = <span class="hljs-keyword">True</span>
<span class="hljs-comment"># layout8(text_boxes)</span>

<span class="hljs-comment"># Better, but newlines should not really take any space should they?</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_blue</span><span class="hljs-params">(boxes)</span>:</span>
    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> boxes:
        <span class="hljs-keyword">if</span> b.letter == <span class="hljs-string">&apos;\n&apos;</span>:
            b.blue = <span class="hljs-keyword">True</span>
            b.w = <span class="hljs-number">0</span>


add_blue(text_boxes)
<span class="hljs-comment"># layout8(text_boxes)</span>

<span class="hljs-comment"># Our big_box is very wide now, that is why we have long lines. Let&apos;s make it narrower</span>
big_box = Box(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>, <span class="hljs-number">1000</span>)
<span class="hljs-comment"># layout8(text_boxes)</span>

<span class="hljs-comment"># But our right side is ragged again! We should make spaces red.</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_red</span><span class="hljs-params">(boxes)</span>:</span>
    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> boxes:
        <span class="hljs-keyword">if</span> b.letter == <span class="hljs-string">&apos; &apos;</span>:
            b.red = <span class="hljs-keyword">True</span>


add_red(text_boxes)
<span class="hljs-comment"># layout8(text_boxes)</span>

<span class="hljs-comment"># The second paragraph of Chapter 1 shows a red space as first thing in the row, and that looks bad!</span>
<span class="hljs-comment"># So, when the 1st letter in a row is a space, let&apos;s make it take no width and not stretch</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout9</span><span class="hljs-params">(boxes)</span>:</span>
    last_break = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i, box <span class="hljs-keyword">in</span> enumerate(boxes[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
        prev_box = boxes[i - <span class="hljs-number">1</span>]
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        <span class="hljs-keyword">if</span> prev_box.blue <span class="hljs-keyword">or</span> box.x &gt; big_box.w:
            box.x = <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> box.red:
                box.w = <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> prev_box.blue:
                box.y = prev_box.y + <span class="hljs-number">2.1</span>
            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># not blue</span>
                box.y = prev_box.y + <span class="hljs-number">1.1</span>
                row = boxes[last_break:i]
                slack = big_box.w - (row[<span class="hljs-number">-1</span>].x + row[<span class="hljs-number">-1</span>].w)
                <span class="hljs-comment"># If the 1st thing is a red, that one doesn&apos;t stretch</span>
                reds = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> row[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> b.red]
                <span class="hljs-comment"># sometimes there is no red in the row. Do nothing.</span>
                <span class="hljs-keyword">if</span> reds:
                    mini_slack = slack / len(reds)
                    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> reds:
                        b.w += mini_slack
                    <span class="hljs-keyword">for</span> j, b <span class="hljs-keyword">in</span> enumerate(row[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
                        b.x = row[j - <span class="hljs-number">1</span>].x + row[j - <span class="hljs-number">1</span>].w + separation
            last_break = i


<span class="hljs-comment"># Just for fun, let&apos;s draw it without the colored boxes</span>
<span class="hljs-comment"># layout9(text_boxes)</span>
<span class="hljs-comment"># draw_boxes(text_boxes, False)</span>

<span class="hljs-comment"># XXX layout9 rewritten using pop(), need to backport this version</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout10</span><span class="hljs-params">(_boxes)</span>:</span>
    boxes = _boxes[:]  <span class="hljs-comment"># Work on a copy</span>
    prev_box = boxes.pop(<span class="hljs-number">0</span>)
    row = [prev_box]
    <span class="hljs-keyword">while</span> (boxes):
        box = boxes.pop(<span class="hljs-number">0</span>)
        row.append(box)
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        <span class="hljs-keyword">if</span> prev_box.blue <span class="hljs-keyword">or</span> box.x &gt; big_box.w:
            box.x = <span class="hljs-number">0</span>
            row.pop()  <span class="hljs-comment"># our box will go in the next row</span>
            <span class="hljs-keyword">if</span> box.red:
                box.w = <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> prev_box.blue:
                box.y = prev_box.y + <span class="hljs-number">2.1</span>

            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># not blue</span>
                box.y = prev_box.y + <span class="hljs-number">1.1</span>
                slack = big_box.w - (row[<span class="hljs-number">-1</span>].x + row[<span class="hljs-number">-1</span>].w)
                <span class="hljs-comment"># If the 1st thing is a red, that one doesn&apos;t stretch</span>
                reds = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> row[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> b.red]
                <span class="hljs-comment"># sometimes there is no red in the row. Do nothing.</span>
                <span class="hljs-keyword">if</span> reds:
                    mini_slack = slack / len(reds)
                    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> reds:
                        b.w += mini_slack
                    <span class="hljs-keyword">for</span> j, b <span class="hljs-keyword">in</span> enumerate(row[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
                        b.x = row[j - <span class="hljs-number">1</span>].x + row[j - <span class="hljs-number">1</span>].w + separation
            row = [box]
        prev_box = box


<span class="hljs-comment"># layout10(text_boxes)</span>

<span class="hljs-comment"># Looks good, except that the words are broken wrong. You can&apos;t break good like: g</span>
<span class="hljs-comment"># ood!</span>

<span class="hljs-comment"># What if we only break on spaces?</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout11</span><span class="hljs-params">(_boxes)</span>:</span>
    boxes = _boxes[:]  <span class="hljs-comment"># Work on a copy</span>
    prev_box = boxes.pop(<span class="hljs-number">0</span>)
    row = [prev_box]
    <span class="hljs-keyword">while</span> (boxes):
        box = boxes.pop(<span class="hljs-number">0</span>)
        row.append(box)
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        <span class="hljs-keyword">if</span> prev_box.blue <span class="hljs-keyword">or</span> (box.x &gt; big_box.w <span class="hljs-keyword">and</span> box.red):
            row.pop()  <span class="hljs-comment"># our box will go in the next row</span>
            box.x = <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> box.red:
                box.w = <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> prev_box.blue:
                box.y = prev_box.y + <span class="hljs-number">2.1</span>

            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># not blue</span>
                box.y = prev_box.y + <span class="hljs-number">1.1</span>
                slack = big_box.w - (row[<span class="hljs-number">-1</span>].x + row[<span class="hljs-number">-1</span>].w)
                <span class="hljs-comment"># If the 1st thing is a red, that one doesn&apos;t stretch</span>
                reds = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> row[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> b.red]
                <span class="hljs-comment"># sometimes there is no red in the row. Do nothing.</span>
                <span class="hljs-keyword">if</span> reds:
                    mini_slack = slack / len(reds)
                    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> reds:
                        b.w += mini_slack
                    <span class="hljs-keyword">for</span> j, b <span class="hljs-keyword">in</span> enumerate(row[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
                        b.x = row[j - <span class="hljs-number">1</span>].x + row[j - <span class="hljs-number">1</span>].w + separation
            row = [box]
        prev_box = box


<span class="hljs-comment"># layout11(text_boxes)</span>

<span class="hljs-comment"># That actually ... worked? Except that when we need to fit something wider than</span>
<span class="hljs-comment"># big_box because we did not break the row, the slack is NEGATIVE and words get</span>
<span class="hljs-comment"># smushed together!</span>

<span class="hljs-comment"># What we actually need is hyphenation.</span>
<span class="hljs-comment"># We can use pyphen to insert soft-hyphen characters wherever words can break.</span>
<span class="hljs-comment"># And we can mark those positions yellow.</span>

<span class="hljs-keyword">import</span> pyphen

hyphenator = pyphen.Pyphen(
    lang=<span class="hljs-string">&apos;en_GB&apos;</span>
)  <span class="hljs-comment"># These things are language dependent</span>

p_and_p = open(<span class="hljs-string">&apos;pride-and-prejudice.txt&apos;</span>).readlines()
<span class="hljs-keyword">for</span> i, l <span class="hljs-keyword">in</span> enumerate(p_and_p):
    words = l.split(<span class="hljs-string">&apos; &apos;</span>)
    p_and_p[i] = <span class="hljs-string">&apos; &apos;</span>.join(
        hyphenator.inserted(w, <span class="hljs-string">&apos;\u00AD&apos;</span>) <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> words
    )
p_and_p = <span class="hljs-string">&apos;&apos;</span>.join(p_and_p)

text_boxes = []
<span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> p_and_p:
    text_boxes.append(Box(letter=l))


<span class="hljs-comment"># This makes the characters &apos;\u00AD&apos; (soft-hyphen) yellow.</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_yellow</span><span class="hljs-params">(boxes)</span>:</span>
    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> boxes:
        <span class="hljs-keyword">if</span> b.letter == <span class="hljs-string">&apos;\u00AD&apos;</span>:
            b.yellow = <span class="hljs-keyword">True</span>


add_blue(text_boxes)
add_red(text_boxes)
add_yellow(text_boxes)
adjust_widths_by_letter(text_boxes)

<span class="hljs-comment"># And create a new layout function that also breaks on yellow boxes.</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout12</span><span class="hljs-params">(_boxes)</span>:</span>
    boxes = _boxes[:]  <span class="hljs-comment"># Work on a copy</span>
    prev_box = boxes.pop(<span class="hljs-number">0</span>)
    row = [prev_box]
    <span class="hljs-keyword">while</span> (boxes):
        box = boxes.pop(<span class="hljs-number">0</span>)
        row.append(box)
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        <span class="hljs-keyword">if</span> prev_box.blue <span class="hljs-keyword">or</span> (
            box.x &gt; big_box.w <span class="hljs-keyword">and</span> (box.red <span class="hljs-keyword">or</span> box.yellow)
        ):
            row.pop()  <span class="hljs-comment"># our box will go in the next row</span>
            box.x = <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> box.red:
                box.w = <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> prev_box.blue:
                box.y = prev_box.y + <span class="hljs-number">2.1</span>

            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># not blue</span>
                box.y = prev_box.y + <span class="hljs-number">1.1</span>
                slack = big_box.w - (row[<span class="hljs-number">-1</span>].x + row[<span class="hljs-number">-1</span>].w)
                <span class="hljs-comment"># If the 1st thing is a red, that one doesn&apos;t stretch</span>
                reds = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> row[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> b.red]
                <span class="hljs-comment"># sometimes there is no red in the row. Do nothing.</span>
                <span class="hljs-keyword">if</span> reds:
                    mini_slack = slack / len(reds)
                    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> reds:
                        b.w += mini_slack
                    <span class="hljs-keyword">for</span> j, b <span class="hljs-keyword">in</span> enumerate(row[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
                        b.x = row[j - <span class="hljs-number">1</span>].x + row[j - <span class="hljs-number">1</span>].w + separation
            row = [box]
        prev_box = box


<span class="hljs-comment"># layout12(text_boxes)</span>

<span class="hljs-comment"># Better! Since we have more break chances, there is less word-smushing.</span>
<span class="hljs-comment"># However our typography is wrong, because we are hyphenating but not showing a hyphen!</span>
<span class="hljs-comment"># So, we need to ADD a box when we hyphenate. That special box is hyphenbox():</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hyphenbox</span><span class="hljs-params">()</span>:</span>  <span class="hljs-comment"># Yes, this is not optimal</span>
    b = Box(letter=<span class="hljs-string">&apos;-&apos;</span>, yellow=<span class="hljs-keyword">True</span>)
    adjust_widths_by_letter([b])
    <span class="hljs-keyword">return</span> b


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout13</span><span class="hljs-params">(_boxes)</span>:</span>
    boxes = _boxes[:]  <span class="hljs-comment"># Work on a copy</span>
    prev_box = boxes.pop(<span class="hljs-number">0</span>)
    row = [prev_box]
    <span class="hljs-keyword">while</span> (boxes):
        box = boxes.pop(<span class="hljs-number">0</span>)
        row.append(box)
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        <span class="hljs-keyword">if</span> prev_box.blue <span class="hljs-keyword">or</span> (
            box.x &gt; big_box.w <span class="hljs-keyword">and</span> (box.red <span class="hljs-keyword">or</span> box.yellow)
        ):
            row.pop()  <span class="hljs-comment"># our box will go in the next row</span>
            <span class="hljs-keyword">if</span> box.yellow:  <span class="hljs-comment"># We need to insert the hyphen!</span>
                h_b = hyphenbox()
                h_b.x = prev_box.x + prev_box.w + separation
                h_b.y = prev_box.y
                _boxes.append(h_b)  <span class="hljs-comment"># So it&apos;s drawn</span>
                row.append(h_b)  <span class="hljs-comment"># So it&apos;s justified</span>
            box.x = <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> box.red:
                box.w = <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> prev_box.blue:
                box.y = prev_box.y + <span class="hljs-number">2.1</span>

            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># not blue</span>
                box.y = prev_box.y + <span class="hljs-number">1.1</span>
                slack = big_box.w - (row[<span class="hljs-number">-1</span>].x + row[<span class="hljs-number">-1</span>].w)
                <span class="hljs-comment"># If the 1st thing is a red, that one doesn&apos;t stretch</span>
                reds = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> row[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> b.red]
                <span class="hljs-comment"># sometimes there is no red in the row. Do nothing.</span>
                <span class="hljs-keyword">if</span> reds:
                    mini_slack = slack / len(reds)
                    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> reds:
                        b.w += mini_slack
                    <span class="hljs-keyword">for</span> j, b <span class="hljs-keyword">in</span> enumerate(row[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
                        b.x = row[j - <span class="hljs-number">1</span>].x + row[j - <span class="hljs-number">1</span>].w + separation
            row = [box]
        prev_box = box


<span class="hljs-comment"># layout13(text_boxes)</span>

<span class="hljs-comment"># Good. However, we still have smushing. It&apos;s usually considered better to make spaces</span>
<span class="hljs-comment"># between words grow, rather than shrink. So, what we should do is, instead of breaking</span>
<span class="hljs-comment"># in the 1st yellow/red PAST the break, go back and break in the last BEFORE the break!</span>

<span class="hljs-comment"># XXX backport simplifications from layout14: separation of blue case</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout14</span><span class="hljs-params">(_boxes)</span>:</span>
    boxes = _boxes[:]  <span class="hljs-comment"># Work on a copy</span>
    row = [boxes.pop(<span class="hljs-number">0</span>)]
    <span class="hljs-keyword">while</span> (boxes):
        prev_box = row[<span class="hljs-number">-1</span>]
        box = boxes.pop(<span class="hljs-number">0</span>)
        row.append(box)
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        <span class="hljs-keyword">if</span> prev_box.blue:
            box.x = <span class="hljs-number">0</span>
            box.y = prev_box.y + <span class="hljs-number">2.1</span>
            row.pop()
            row = [box]

        <span class="hljs-keyword">elif</span> box.x &gt; big_box.w:
            <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> (box.red <span class="hljs-keyword">or</span> box.yellow):  <span class="hljs-comment"># backtrack onw</span>
                boxes.insert(<span class="hljs-number">0</span>, row.pop())
                <span class="hljs-comment"># tip of row is now box, previous one is prev_box</span>
                box = row[<span class="hljs-number">-1</span>]
                prev_box = row[<span class="hljs-number">-2</span>]

            row.pop()  <span class="hljs-comment"># Breaking box goes in next row</span>
            <span class="hljs-keyword">if</span> box.yellow:  <span class="hljs-comment"># We need to insert the hyphen!</span>
                h_b = hyphenbox()
                h_b.x = prev_box.x + prev_box.w + separation
                h_b.y = prev_box.y
                _boxes.append(h_b)  <span class="hljs-comment"># So it&apos;s drawn</span>
                row.append(h_b)  <span class="hljs-comment"># So it&apos;s justified</span>
            box.x = <span class="hljs-number">0</span>
            box.y = prev_box.y + <span class="hljs-number">1.1</span>
            <span class="hljs-keyword">if</span> box.red:
                box.w = <span class="hljs-number">0</span>
            slack = big_box.w - (row[<span class="hljs-number">-1</span>].x + row[<span class="hljs-number">-1</span>].w)
            <span class="hljs-comment"># If the 1st thing is a red, that one doesn&apos;t stretch</span>
            reds = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> row[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> b.red]
            <span class="hljs-comment"># sometimes there is no red in the row. Do nothing.</span>
            <span class="hljs-keyword">if</span> reds:
                mini_slack = slack / len(reds)
                <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> reds:
                    b.w += mini_slack
                <span class="hljs-keyword">for</span> j, b <span class="hljs-keyword">in</span> enumerate(row[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
                    b.x = row[j - <span class="hljs-number">1</span>].x + row[j - <span class="hljs-number">1</span>].w + separation
            row = [box]


<span class="hljs-comment"># With a little separation for niceness, the result is not half bad!</span>
separation = <span class="hljs-number">0.05</span>
<span class="hljs-comment"># layout14(text_boxes)</span>

<span class="hljs-comment"># So far, our big_box has been very, very tall. What would happen if it were short?</span>
big_box = Box(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>, <span class="hljs-number">60</span>)
<span class="hljs-comment"># layout14(text_boxes)</span>

<span class="hljs-comment"># Well, that our text flows straight out of the box! And our initial problem was</span>
<span class="hljs-comment"># &quot;So, how could we layout the many boxes inside the big_box?&quot; !</span>
<span class="hljs-comment"># That won&apos;t do. Clearly, if we have more text than fits in a box, we need more than one</span>
<span class="hljs-comment"># box. Like pages.</span>

<span class="hljs-comment"># So, let&apos;s make many big boxes.</span>


pages = [Box(<span class="hljs-number">0</span>, i * <span class="hljs-number">65</span>, <span class="hljs-number">30</span>, <span class="hljs-number">60</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>)]

<span class="hljs-comment"># layout14(text_boxes)</span>

<span class="hljs-comment"># Of course our layout engine does nothing with those pages. Let&apos;s fix that.</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout15</span><span class="hljs-params">(_boxes)</span>:</span>
    boxes = _boxes[:]  <span class="hljs-comment"># Work on a copy</span>
    row = [boxes.pop(<span class="hljs-number">0</span>)]

    <span class="hljs-comment"># Put the 1st box in the beginning of the 1st page</span>
    page = <span class="hljs-number">0</span>
    row[<span class="hljs-number">0</span>].x = pages[page].x
    row[<span class="hljs-number">0</span>].y = pages[page].y

    <span class="hljs-keyword">while</span> (boxes):
        prev_box = row[<span class="hljs-number">-1</span>]
        box = boxes.pop(<span class="hljs-number">0</span>)
        row.append(box)
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        <span class="hljs-keyword">if</span> prev_box.blue:
            box.x = <span class="hljs-number">0</span>
            box.y = prev_box.y + <span class="hljs-number">2.1</span>
            row.pop()
            row = [box]

        <span class="hljs-keyword">elif</span> box.x &gt; pages[page].w:
            <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> (box.red <span class="hljs-keyword">or</span> box.yellow):  <span class="hljs-comment"># backtrack onw</span>
                boxes.insert(<span class="hljs-number">0</span>, row.pop())
                <span class="hljs-comment"># tip of row is now box, previous one is prev_box</span>
                box = row[<span class="hljs-number">-1</span>]
                prev_box = row[<span class="hljs-number">-2</span>]

            row.pop()  <span class="hljs-comment"># Breaking box goes in next row</span>
            <span class="hljs-keyword">if</span> box.yellow:  <span class="hljs-comment"># We need to insert the hyphen!</span>
                h_b = hyphenbox()
                h_b.x = prev_box.x + prev_box.w + separation
                h_b.y = prev_box.y
                _boxes.append(h_b)  <span class="hljs-comment"># So it&apos;s drawn</span>
                row.append(h_b)  <span class="hljs-comment"># So it&apos;s justified</span>
            box.x = <span class="hljs-number">0</span>
            box.y = prev_box.y + <span class="hljs-number">1.1</span>
            <span class="hljs-keyword">if</span> box.red:
                box.w = <span class="hljs-number">0</span>
            slack = pages[page].w - (row[<span class="hljs-number">-1</span>].x + row[<span class="hljs-number">-1</span>].w)
            <span class="hljs-comment"># If the 1st thing is a red, that one doesn&apos;t stretch</span>
            reds = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> row[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> b.red]
            <span class="hljs-comment"># sometimes there is no red in the row. Do nothing.</span>
            <span class="hljs-keyword">if</span> reds:
                mini_slack = slack / len(reds)
                <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> reds:
                    b.w += mini_slack
                <span class="hljs-keyword">for</span> j, b <span class="hljs-keyword">in</span> enumerate(row[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
                    b.x = row[j - <span class="hljs-number">1</span>].x + row[j - <span class="hljs-number">1</span>].w + separation
            row = [box]

        <span class="hljs-keyword">if</span> box.y + box.h &gt; pages[page].y + pages[page].h:
            <span class="hljs-comment"># We need to go to the next page</span>
            page = page + <span class="hljs-number">1</span>
            box.y = pages[page].y


<span class="hljs-comment"># layout15(text_boxes)</span>
<span class="hljs-comment"># And there you go, pagination</span>

<span class="hljs-comment"># What happens if pages are organized differently?</span>
<span class="hljs-comment"># Let&apos;s put them left-to-right</span>
pages = [Box(i * <span class="hljs-number">35</span>, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>, <span class="hljs-number">60</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>)]
<span class="hljs-comment"># layout15(text_boxes)</span>

<span class="hljs-comment"># Everything is in the same page, because we are resetting x to 0 on line breaks.</span>
<span class="hljs-comment"># You always need to find your hidden assumptions.</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">layout16</span><span class="hljs-params">(_boxes)</span>:</span>
    boxes = _boxes[:]  <span class="hljs-comment"># Work on a copy</span>
    row = [boxes.pop(<span class="hljs-number">0</span>)]

    <span class="hljs-comment"># Put the 1st box in the beginning of the 1st page</span>
    page = <span class="hljs-number">0</span>
    row[<span class="hljs-number">0</span>].x = pages[page].x
    row[<span class="hljs-number">0</span>].y = pages[page].y

    <span class="hljs-keyword">while</span> (boxes):
        prev_box = row[<span class="hljs-number">-1</span>]
        box = boxes.pop(<span class="hljs-number">0</span>)
        row.append(box)
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        <span class="hljs-keyword">if</span> prev_box.blue:
            box.x = pages[page].x
            box.y = prev_box.y + <span class="hljs-number">2.1</span>
            row.pop()
            row = [box]

        <span class="hljs-keyword">elif</span> box.x &gt; pages[page].w + pages[page].x:
            <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> (box.red <span class="hljs-keyword">or</span> box.yellow):  <span class="hljs-comment"># backtrack onw</span>
                boxes.insert(<span class="hljs-number">0</span>, row.pop())
                <span class="hljs-comment"># tip of row is now box, previous one is prev_box</span>
                box = row[<span class="hljs-number">-1</span>]
                prev_box = row[<span class="hljs-number">-2</span>]

            row.pop()  <span class="hljs-comment"># Breaking box goes in next row</span>
            <span class="hljs-keyword">if</span> box.yellow:  <span class="hljs-comment"># We need to insert the hyphen!</span>
                h_b = hyphenbox()
                h_b.x = prev_box.x + prev_box.w + separation
                h_b.y = prev_box.y
                _boxes.append(h_b)  <span class="hljs-comment"># So it&apos;s drawn</span>
                row.append(h_b)  <span class="hljs-comment"># So it&apos;s justified</span>
            box.x = pages[page].x
            box.y = prev_box.y + <span class="hljs-number">1.1</span>
            <span class="hljs-keyword">if</span> box.red:
                box.w = <span class="hljs-number">0</span>
            slack = (pages[page].w + pages[page].x) - (
                row[<span class="hljs-number">-1</span>].x + row[<span class="hljs-number">-1</span>].w
            )
            <span class="hljs-comment"># If the 1st thing is a red, that one doesn&apos;t stretch</span>
            reds = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> row[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> b.red]
            <span class="hljs-comment"># sometimes there is no red in the row. Do nothing.</span>
            <span class="hljs-keyword">if</span> reds:
                mini_slack = slack / len(reds)
                <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> reds:
                    b.w += mini_slack
                <span class="hljs-keyword">for</span> j, b <span class="hljs-keyword">in</span> enumerate(row[<span class="hljs-number">1</span>:], <span class="hljs-number">1</span>):
                    b.x = row[j - <span class="hljs-number">1</span>].x + row[j - <span class="hljs-number">1</span>].w + separation
            row = [box]

        <span class="hljs-comment"># We may need to go to the next page</span>
        <span class="hljs-keyword">if</span> box.y + box.h &gt; pages[page].y + pages[page].h:
            page = page + <span class="hljs-number">1</span>
            <span class="hljs-comment"># Since the location of a page is arbitrary, both coordinates are reset</span>
            box.y = pages[page].y
            box.x = pages[page].x


<span class="hljs-comment"># This may even work with oddly-sized pages!</span>
pages = [
    Box(i * <span class="hljs-number">35</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">60</span> + random.randint(<span class="hljs-number">-20</span>, <span class="hljs-number">20</span>)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>)
]

layout16(text_boxes)
draw_boxes(text_boxes, <span class="hljs-keyword">False</span>)

<span class="hljs-comment"># This is a good point to STOP. Look at the code, and clean house.</span>
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="code.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: Code Listings">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Original Code","level":"1.6.1","depth":2,"previous":{"title":"Code Listings","level":"1.6","depth":1,"path":"code.md","ref":"./code.md","articles":[{"title":"Original Code","level":"1.6.1","depth":2,"path":"original.run.md","ref":"./original.run.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":[],"root":"./src","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"gitbook":"*"},"file":{"path":"original.run.md","mtime":"2018-03-28T12:35:40.817Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-03-31T19:15:08.294Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

