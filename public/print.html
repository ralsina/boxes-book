<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BOXES (WIP title)</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The whole lifecycle of a project.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="custom.css">
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <noscript>
            <style type="text/css">
                .javascript-only {
                    display: none;
                }
            </style>
        </noscript>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="cover.html">Cover</a></li><li class="affix"><a href="intro.html">Introduction</a></li><li><a href="part1/finger_thinking.html"><strong aria-hidden="true">1.</strong> Part 1: Finger Thinking</a></li><li><ol class="section"><li><a href="part1/lesson0.run.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li><a href="part1/lesson1.run.html"><strong aria-hidden="true">1.2.</strong> Lesson 1</a></li><li><a href="part1/lesson2.run.html"><strong aria-hidden="true">1.3.</strong> Lesson 2</a></li><li><a href="part1/lesson3.run.html"><strong aria-hidden="true">1.4.</strong> Lesson 3</a></li><li><a href="part1/lesson4.run.html"><strong aria-hidden="true">1.5.</strong> Lesson 4</a></li><li><a href="part1/lesson5.run.html"><strong aria-hidden="true">1.6.</strong> Lesson 5</a></li><li><a href="part1/lesson6.run.html"><strong aria-hidden="true">1.7.</strong> Lesson 6</a></li><li><a href="part1/lesson7.run.html"><strong aria-hidden="true">1.8.</strong> Lesson 7</a></li><li><a href="part1/lesson8.run.html"><strong aria-hidden="true">1.9.</strong> Lesson 8</a></li><li><a href="part1/lesson9.run.html"><strong aria-hidden="true">1.10.</strong> Lesson 9</a></li><li><a href="part1/lesson10.run.html"><strong aria-hidden="true">1.11.</strong> Lesson 10</a></li><li><a href="part1/lesson11.run.html"><strong aria-hidden="true">1.12.</strong> Lesson 11</a></li><li><a href="part1/recap.html"><strong aria-hidden="true">1.13.</strong> Recapitulation</a></li></ol></li><li><a href="part2/ducks_in_a_row.html"><strong aria-hidden="true">2.</strong> Part 2: Ducks in a Row</a></li><li><ol class="section"><li><a href="part2/lesson0.run.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li><a href="part2/lesson1.run.html"><strong aria-hidden="true">2.2.</strong> Lesson 1</a></li></ol></li><li><a href="wax_on_wax_off.html"><strong aria-hidden="true">3.</strong> Part 3: Wax On, Wax Off</a></li><li><a href="going_public.html"><strong aria-hidden="true">4.</strong> Part 4: Going Public</a></li><li><a href="code.html"><strong aria-hidden="true">5.</strong> Code Listings</a></li><li><ol class="section"><li><a href="original.run.html"><strong aria-hidden="true">5.1.</strong> Original Code</a></li></ol></li><li><a href="dependencies.html">Dependencies</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons javascript-only">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">BOXES (WIP title)</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </div>
                <div id="searchresults-outer" class="searchresults-outer">
                    <div class="searchresults-header" id="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="cover.svg" alt="cover.svg" /></p>
<a class="header" href="print.html#introduction" id="introduction"><h1>Introduction</h1></a>
<p>This book tries to achieve only one thing:</p>
<p>Show you a project go from <strong>nothing</strong> to <strong>OK</strong>.</p>
<p>By nothing I mean, no code at all. Not even a fleshed idea of what it does. No
goals, no commitments. Just a vague interest.</p>
<p>And by OK I mean it will work, it will have tests, it will be available to
use, it will be <strong>useful</strong> and be a real thing.</p>
<p>Think of it as a sort of documentary on the beginnings of a rock band, only
instead of rockers there is a single overweight Argentinian dev, and instead
of a band there is a piece of software.</p>
<p>So, not much like a documentary on the beginnings of a rock band.</p>
<a class="header" href="print.html#target-audience" id="target-audience"><h2>Target Audience</h2></a>
<p>To get the most benefit from this book I expect the reader to have a basic
knowledge of the Python programming language. Knowing and
understanding the contents of the official
<a href="https://docs.python.org/3/tutorial/">Python Tutorial.</a> should be enough to be
able to follow all the code in the book, which has been kept as simple as
possible.</p>
<p>Readers with deeper knowledge of the language or more extensive programming
experience may still benefit from it but will find a lot of the first part
boring.</p>
<a class="header" href="print.html#requirements" id="requirements"><h2>Requirements</h2></a>
<p>You can try to follow the book by just reading it but that is probably not the
best idea. Actually running the example code is educational. Modifying it
even more so.</p>
<p>So, you will need a working python interpreter.
The examples have only been tested on Linux. I suppose before calling this
book &quot;finished&quot; I will have to make them work on Windows and/or OS X somehow.</p>
<p>Each one of the larger parts of the book requires a separate development
environment and has a &quot;Chapter 0&quot; about setting it up.</p>
<blockquote>
<a class="header" href="print.html#how-the-book-is-built" id="how-the-book-is-built"><h3>How the book is built</h3></a>
<ul>
<li>It's written in markdown</li>
<li>The sections with code are fed to <a href="https://github.com/bslatkin/pyliterate">pyliterate</a> and its output is built into a &quot;book&quot; by <a href="https://github.com/rust-lang-nursery/mdBook">mdbook</a></li>
<li>The code uses a ton of things, links are provided in the <a href="dependencies.html">Dependencies Appendix</a></li>
<li>All the code and text for the book is available in a <a href="https://gitlab.com/ralsina/boxes-book">gitlab repo</a> and it's published and updated at <a href="https://ralsina.gitlab.io/boxes-book/">https://ralsina.gitlab.io</a></li>
</ul>
</blockquote>
<a class="header" href="print.html#finger-thinking" id="finger-thinking"><h1>Finger Thinking</h1></a>
<p>This is the first part of the book, and the goal is starting a project from scratch. This happens in the beginning of many programming books, but I have
this feeling that they are lying to me.</p>
<p>The code seems rehearsed, there are no errors, everything progresses monotonically towards a lovely pyramid of code with no false starts and no wrong assumptions.</p>
<p>In the decades I have programmed, that has <strong>never</strong> happened to me. Not once. So, I guess those &quot;start from scratch&quot; things are actually done backwards, from
the working butterfly into a fake larva, or they are much better at this than I. Since I am not <strong>that</strong> awful a programmer, I have decided to believe the former, and take a shot at doing it the opposite way.</p>
<p>Everything you see here is in the order I wrote it. I have, occasionally, gone back and cleaned up a bad idea, but trust me, there are plenty still left.</p>
<hr />
<p>Sometimes, when you start a project, you will find that you don't have a clear goal. Some of my most fun projects were created because I was doing the equivalent of doodling on a computer.</p>
<p>Sometimes, it starts with a post on a blog, or a link on twitter, and I just think &quot;hmmm, I wonder how that's done&quot; or &quot;well, that sounds fun to write&quot; or
&quot;that doesn't look so hard!&quot; (those usually <em>are</em> so hard.)</p>
<p>So, I doodle on the interpreter, or in a throwaway script file. No tests, no
requirements, no fuzz.</p>
<p>The first part of this book is, then, an iterative doodle, showing the infancy of a project, and almost literally thinking with my fingers, and having them tell me where to go.</p>
<p>In later sections, things will get much more serious. So, enjoy this part.</p>
<a class="header" href="print.html#setup" id="setup"><h1>SETUP</h1></a>
<a class="header" href="print.html#boxes-v01" id="boxes-v01"><h1>BOXES v0.1</h1></a>
<p>Welcome to Boxes v1. I want to be able to draw some boxes. By boxes I don't mean actual boxes,
but rather squares. I found a library called svgwrite that lets you do that pretty easily.</p>
<p>First let's create a data structure. A simple class called Box.</p>
<pre><code class="language-python"># lesson1.py
class Box():

    def __init__(self, x=0, y=0, w=1, h=1):
        &quot;&quot;&quot;Accept arguments to define our box, and store them.&quot;&quot;&quot;
        self.x = x
        self.y = y
        self.w = w
        self.h = h

    def __repr__(self):
        return 'Box(%s, %s, %s, %s)' % (self.x, self.y, self.w, self.y)

</code></pre>
<p>As you can see that is a pretty simple class. And we can create a big box.</p>
<pre><code class="language-python">big_box = Box(0, 0, 80, 100)
</code></pre>
<p>Or many boxes using a <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions">list comprehension</a></p>
<pre><code class="language-python"># lesson1.py
many_boxes = [Box() for i in range(5000)]

</code></pre>
<p>So now we have a big box, and 5000 smaller boxes, all alike.</p>
<pre><code class="language-python"># Print the first 10 boxes
print(many_boxes[:10])
</code></pre>
<pre><code>[Box(0, 0, 1, 0), Box(0, 0, 1, 0), Box(0, 0, 1, 0), Box(0, 0, 1, 0), Box(0, 0, 1, 0), Box(0, 0, 1, 0), Box(0, 0, 1, 0), Box(0, 0, 1, 0), Box(0, 0, 1, 0), Box(0, 0, 1, 0)]
</code></pre>
<p>And yes, we can draw those boxes.</p>
<pre><code class="language-python"># lesson1.py
import svgwrite


def draw_boxes(boxes, fname, size):
    dwg = svgwrite.Drawing(fname, profile='full', size=size)
    # Draw all the boxes
    for box in boxes:
        dwg.add(
            dwg.rect(
                insert=(box.x, box.y), size=(box.w, box.h), fill='red'
            )
        )
    dwg.save()


draw_boxes(many_boxes, 'lesson1.svg', (5, 2))

</code></pre>
<p>And here is the output:</p>
<p><img src="/part1/lesson1.svg" alt="lesson1.svg" /></p>
<p>That ... was not very interesting. It's a single small red square!</p>
<p>Remember <em>all our boxes have the same size and position!</em></p>
<p>So ... we should do something better. Or at least more interesting, in lesson 2.</p>
<hr />
<p>Further references:</p>
<ul>
<li>Full source code for this lesson: <a href="lesson1.py.run.html">lesson1.py</a></li>
</ul>
<a class="header" href="print.html#boxes-v02" id="boxes-v02"><h1>BOXES v0.2</h1></a>
<p>In our <a href="lesson1.run.html">previous lesson</a> we created a rather disappointing
drawing using boxes. Let's introduce a new wrinkle, and <strong>layout</strong> the many
boxes.</p>
<p>This code is just like before:</p>
<pre><code class="language-python"># lesson2.py
class Box():

    def __init__(self, x=0, y=0, w=1, h=1):
        &quot;&quot;&quot;Accept arguments to define our box, and store them.&quot;&quot;&quot;
        self.x = x
        self.y = y
        self.w = w
        self.h = h

    def __repr__(self):
        return 'Box(%s, %s, %s, %s)' % (self.x, self.y, self.w, self.y)


many_boxes = [Box() for i in range(5000)]

</code></pre>
<p>But now, so they are not all stuck one on top of the other, let's lay the boxes down in a line, one next to the other.</p>
<pre><code class="language-python"># lesson2.py
# We add a &quot;separation&quot; constant so you can see the boxes individually
separation = .2


def layout(boxes):
    for i, box in enumerate(boxes):
        box.x = i * (1 + separation)


layout(many_boxes)

</code></pre>
<p>And we can see that they all have different coordinates now by printing
a few of them. And yes, some of those numbers do look funny. Floating point
numbers are weird.</p>
<pre><code class="language-python">print([(box.x, box.y) for box in many_boxes[:10]])
</code></pre>
<pre><code>[(0.0, 0), (1.2, 0), (2.4, 0), (3.5999999999999996, 0), (4.8, 0), (6.0, 0), (7.199999999999999, 0), (8.4, 0), (9.6, 0), (10.799999999999999, 0)]
</code></pre>
<p>Let's draw them!</p>
<pre><code class="language-python"># lesson2.py
import svgwrite


def draw_boxes(boxes, fname, size):
    dwg = svgwrite.Drawing(fname, profile='full', size=size)
    # Draw all the boxes
    for box in boxes:
        dwg.add(
            dwg.rect(
                insert=(box.x, box.y), size=(box.w, box.h), fill='red'
            )
        )
    dwg.save()


draw_boxes(many_boxes, 'lesson2.svg', (5, 2))

</code></pre>
<p>And here is the output:</p>
<p><img src="part1/lesson2.svg" alt="lesson2.svg" /></p>
<p>That was more or less what we expected, right? Of course since there are 5000 small
boxes that row of boxes goes on for quite a while.</p>
<p>We <em>could</em> just go to the right for a while, then start a new row. Let's do that in
the next lesson.</p>
<hr />
<p>Further references:</p>
<ul>
<li>Full source code for this lesson <a href="lesson2.py.run.html">lesson2.py</a></li>
<li><a href="part1/code/diffs/lesson1_lesson2.html">Difference with code from last lesson</a></li>
</ul>
<a class="header" href="print.html#boxes-v03" id="boxes-v03"><h1>BOXES v0.3</h1></a>
<p>In our <a href="lesson2.run.html">previous lesson</a> we ended with something like a line
of army ants, all our boxes lined up. Let's make it better by making them
organize themselves in rows.</p>
<p>This code is just like before:</p>
<pre><code class="language-python"># lesson3.py
class Box():

    def __init__(self, x=0, y=0, w=1, h=1):
        &quot;&quot;&quot;Accept arguments to define our box, and store them.&quot;&quot;&quot;
        self.x = x
        self.y = y
        self.w = w
        self.h = h

    def __repr__(self):
        return 'Box(%s, %s, %s, %s)' % (self.x, self.y, self.w, self.y)


many_boxes = [Box() for i in range(5000)]

</code></pre>
<p>But now, let's organize our boxes in rank and file. In fact, let's put our
many boxes inside a big box.</p>
<pre><code class="language-python"># lesson3.py
big_box = Box(0, 0, 30, 50)

</code></pre>
<p>We will get our boxes one at a time, put the first in 0,0 and the next one right
at its right, and so on, and when we are about to step outside of the big box,
we go back to the left, a little down, and do it all over again.</p>
<pre><code class="language-python"># lesson3.py
# We add a &quot;separation&quot; constant so you can see the boxes individually
separation = .2


def layout(_boxes):
    # Because we modify the box list, we will work on a copy
    boxes = _boxes[:]
    # The 1st box is at 0,0 so no need to do anything with it, right?
    previous = boxes.pop(0)
    while boxes:
        # We take the new 1st box
        box = boxes.pop(0)
        # And put it next to the other
        box.x = previous.x + previous.w + separation
        # At the same vertical location
        box.y = previous.y
        # But if it's too far to the right...
        if (box.x + box.w) &gt; big_box.w:
            # We go all the way left and a little down
            box.x = 0
            box.y = previous.y + previous.h + separation
        previous = box


layout(many_boxes)

</code></pre>
<p>And now we can draw it. Just so we are sure we are staying inside the
big box, we will draw it too, in light blue.</p>
<pre><code class="language-python"># lesson3.py
import svgwrite


def draw_boxes(boxes, fname, size):
    dwg = svgwrite.Drawing(fname, profile='full', size=size)
    # Draw the &quot;big box&quot;
    dwg.add(
        dwg.rect(
            insert=(big_box.x, big_box.y),
            size=(big_box.w, big_box.h),
            fill='lightblue',
        )
    )
    # Draw all the boxes
    for box in boxes:
        dwg.add(
            dwg.rect(
                insert=(box.x, box.y), size=(box.w, box.h), fill='red'
            )
        )
    dwg.save()


# Make the visible part of the drawing larger to show big_box
draw_boxes(many_boxes, 'lesson3.svg', (50, 90))

</code></pre>
<p>And here is the output:</p>
<p><img src="part1/lesson3.svg" alt="lesson3.svg" /></p>
<p>That is strangely satisfying! Of course we are doing something wrong in that
we are overflowing the big box vertically.</p>
<p>So, we could have more than one big box. And use them as pages?</p>
<hr />
<p>Further references:</p>
<ul>
<li>Full source code for this lesson <a href="lesson3.py.run.html">lesson3.py</a></li>
<li><a href="part1/code/diffs/lesson2_lesson3.html">Difference with code from last lesson</a></li>
</ul>
<a class="header" href="print.html#boxes-v04" id="boxes-v04"><h1>BOXES v0.4</h1></a>
<p>In the <a href="lesson3.run.html">previous lesson</a> we totally nailed drawing between the lines ... horizontally. Let's improve on that by being bidimensional.</p>
<p>This code is just like before:</p>
<pre><code class="language-python"># lesson4.py
class Box():

    def __init__(self, x=0, y=0, w=1, h=1):
        &quot;&quot;&quot;Accept arguments to define our box, and store them.&quot;&quot;&quot;
        self.x = x
        self.y = y
        self.w = w
        self.h = h

    def __repr__(self):
        return 'Box(%s, %s, %s, %s)' % (self.x, self.y, self.w, self.y)


many_boxes = [Box() for i in range(5000)]

</code></pre>
<p>But now, instead of a big box, let's have a list of, say, 10 pages (or large boxes), one below the other, slighty separated.</p>
<pre><code class="language-python"># lesson4.py
pages = [Box(0, i * 55, 30, 50) for i in range(10)]

</code></pre>
<p>Of course our layout routine needs improvements to handle overflowing a
page vertically.</p>
<pre><code class="language-python"># lesson4.py
# We add a &quot;separation&quot; constant so you can see the boxes individually
separation = .2


def layout(_boxes):
    # Because we modify the box list, we will work on a copy
    boxes = _boxes[:]
    # We start at page 0
    page = 0
    # The 1st box should be placed in the correct page
    previous = boxes.pop(0)
    previous.x = pages[page].x
    previous.y = pages[page].y
    while boxes:
        # We take the new 1st box
        box = boxes.pop(0)
        # And put it next to the other
        box.x = previous.x + previous.w + separation
        # At the same vertical location
        box.y = previous.y
        # But if it's too far to the right...
        if (box.x + box.w) &gt; (pages[page].x + pages[page].w):
            # We go all the way left and a little down
            box.x = pages[page].x
            box.y = previous.y + previous.h + separation

        # But if we go too far down
        if box.y + box.h &gt; pages[page].y + pages[page].h:
            # We go to the next page
            page += 1
            # And put the box at the top-left
            box.x = pages[page].x
            box.y = pages[page].y

        previous = box


layout(many_boxes)

</code></pre>
<p>We need to change our drawing code to draw more than one page.</p>
<pre><code class="language-python"># lesson4.py
import svgwrite


def draw_boxes(boxes, fname, size):
    dwg = svgwrite.Drawing(fname, profile='full', size=size)
    # Draw the pages
    for page in pages:
        dwg.add(
            dwg.rect(
                insert=(page.x, page.y),
                size=(page.w, page.h),
                fill='lightblue',
            )
        )
    # Draw all the boxes
    for box in boxes:
        dwg.add(
            dwg.rect(
                insert=(box.x, box.y), size=(box.w, box.h), fill='red'
            )
        )
    dwg.save()


draw_boxes(many_boxes, 'lesson4.svg', (100, 50))

</code></pre>
<p>And here is the output:</p>
<p><img src="part1/lesson4.svg" alt="lesson4.svg" /></p>
<p>Would this work if the pages are arranged differently? Let's put the pages
side by side instead.</p>
<pre><code class="language-python"># lesson4.py
pages = [Box(i * 35, 0, 30, 50) for i in range(10)]
layout(many_boxes)
draw_boxes(many_boxes, 'lesson4_side_by_side.svg', (100, 50))

</code></pre>
<p><img src="part1/lesson4_side_by_side.svg" alt="lesson4_side_by_side.svg" /></p>
<p>And how about pages of different sizes?</p>
<pre><code class="language-python"># lesson4.py
from random import randint

pages = [
    Box(i * 35, 0, 30 - randint(0, 10), 50 - randint(0, 30))
    for i in range(10)
]
layout(many_boxes)
draw_boxes(many_boxes, 'lesson4_random_sizes.svg', (100, 50))

</code></pre>
<p><img src="part1/lesson4_random_sizes.svg" alt="lesson4_random_sizes.svg" /></p>
<p>So, we can fill pages and pages with little red squares now. Nice!</p>
<p>How about we make the squares not be all the same width?</p>
<pre><code class="language-python"># lesson4.py
many_boxes = [Box(w=1 + randint(-5, 5) / 10) for i in range(5000)]
layout(many_boxes)
draw_boxes(many_boxes, 'lesson4_random_box_sizes.svg', (100, 50))

</code></pre>
<p>This adds &quot;noise&quot; to the width of the boxes, so they are now anything between 0.5 and 1.5 units wide.</p>
<p><img src="part1/lesson4_random_box_sizes.svg" alt="lesson4_random_box_sizes.svg" /></p>
<p>That looks interesting...</p>
<hr />
<p>Further references:</p>
<ul>
<li>Full source code for this lesson <a href="lesson4.py.run.html">lesson4.py</a></li>
<li><a href="part1/code/diffs/lesson3_lesson4.html">Difference with code from last lesson</a></li>
</ul>
<a class="header" href="print.html#boxes-v05" id="boxes-v05"><h1>BOXES v0.5</h1></a>
<p>In our <a href="lesson4.run.html">previous lesson</a> we created code that can fill a series of pages using many small boxes.</p>
<p>But only when those boxes are all alike. Once the boxes had different widths, the right side of our layout got all ragged. You surely have seen things like it when using word processors or reading web pages, where the text is all aligned on the left and all ragged on the right. It's called a &quot;left-aligned&quot; or &quot;ragged-right&quot; layout.</p>
<p>The reason is that we exceed the page width by a random amount, and then,
when moving that box to the next row, we are left a random amount <strong>short</strong> of the desired width.</p>
<p>Could we make it look aligned on BOTH sides? Of course. Let's try.</p>
<p>This code is just like before:</p>
<pre><code class="language-python"># lesson5.py
class Box():

    def __init__(self, x=0, y=0, w=1, h=1):
        &quot;&quot;&quot;Accept arguments to define our box, and store them.&quot;&quot;&quot;
        self.x = x
        self.y = y
        self.w = w
        self.h = h

    def __repr__(self):
        return 'Box(%s, %s, %s, %s)' % (self.x, self.y, self.w, self.y)


# Many boxes with varying widths
from random import randint

many_boxes = [Box(w=1 + randint(-5, 5) / 10) for i in range(5000)]

# A few pages all the same size
pages = [Box(i * 35, 0, 30, 50) for i in range(10)]

</code></pre>
<p>And of course, we need a new layout function. The plan is this:</p>
<ul>
<li>Organize boxes in rows, like before.</li>
<li>When we are about to go too wide, see how much &quot;slack&quot; is left
between the right side of our last box in the row and the edge of
the page.</li>
<li>Spread that slack by sliding all boxes slightly right so noone notices.</li>
</ul>
<pre><code class="language-python"># lesson5.py
# We add a &quot;separation&quot; constant so you can see the boxes individually
separation = .2


def layout(_boxes):
    # Because we modify the box list, we will work on a copy
    boxes = _boxes[:]
    # We start at page 0
    page = 0
    # The 1st box should be placed in the correct page
    previous = boxes.pop(0)
    previous.x = pages[page].x
    previous.y = pages[page].y
    row = []
    while boxes:
        # We take the new 1st box
        box = boxes.pop(0)
        # And put it next to the other
        box.x = previous.x + previous.w + separation
        # At the same vertical location
        box.y = previous.y
        # But if it's too far to the right...
        if (box.x + box.w) &gt; (pages[page].x + pages[page].w):
            # We adjust the row
            slack = (pages[page].x + pages[page].w) - (
                row[-1].x + row[-1].w
            )
            bump = slack / len(row)
            # The 1st box gets 0 bumps, the 2nd gets 1 and so on
            for i, b in enumerate(row):
                b.x += bump * i
            # We start a new row
            row = []
            # We go all the way left and a little down
            box.x = pages[page].x
            box.y = previous.y + previous.h + separation

        # But if we go too far down
        if box.y + box.h &gt; pages[page].y + pages[page].h:
            # We go to the next page
            page += 1
            # And put the box at the top-left
            box.x = pages[page].x
            box.y = pages[page].y

        # Put the box in the row
        row.append(box)
        previous = box


layout(many_boxes)

</code></pre>
<p>The drawing code needs no changes.</p>
<pre><code class="language-python"># lesson5.py
import svgwrite


def draw_boxes(boxes, fname, size):
    dwg = svgwrite.Drawing(fname, profile='full', size=size)
    # Draw the pages
    for page in pages:
        dwg.add(
            dwg.rect(
                insert=(page.x, page.y),
                size=(page.w, page.h),
                fill='lightblue',
            )
        )
    # Draw all the boxes
    for box in boxes:
        dwg.add(
            dwg.rect(
                insert=(box.x, box.y), size=(box.w, box.h), fill='red'
            )
        )
    dwg.save()


draw_boxes(many_boxes, 'lesson5.svg', (100, 50))

</code></pre>
<p><img src="part1/lesson5.svg" alt="lesson5.svg" /></p>
<p>Isn't that nice? If you look at it from afar it looks sort of familiar.
Doesn't it?</p>
<hr />
<p>Further references:</p>
<ul>
<li>Full source code for this lesson <a href="lesson5.py.run.html">lesson5.py</a></li>
<li><a href="part1/code/diffs/lesson4_lesson5.html">Difference with code from last lesson</a></li>
</ul>
<a class="header" href="print.html#boxes-v06" id="boxes-v06"><h1>BOXES v0.6</h1></a>
<p>In our <a href="lesson5.run.html">previous lesson</a> we created a fully justified layout of varying-width boxes spread across multiple pages. But we cheated.</p>
<p>To achieve full justification, we spread the &quot;slack&quot; evenly in the space between all boxes in the row. If we were trying to layout text, that is not the proper way.</p>
<p>You see, text comes separated in words. And usually, in western languages, the words have characters called spaces between them. So what we do, when laying out text, is to make the special <strong>space</strong> boxes slightly larger and keep the separation between boxes constant (in fact, we also tweak separations between letters, but let's ignore that for now. Or for ever.</p>
<p>How about we choose some boxes and decide they, and only they, are stretchy?</p>
<p>That way, our strategy to fully justify the text will be: stretch the stretchy bits on each row just enough so that the row is exactly the width we need.</p>
<p>For the first time in a few lessons, we need to change our Box class:</p>
<pre><code class="language-python"># lesson6.py
class Box():

    def __init__(self, x=0, y=0, w=1, h=1, stretchy=False):
        &quot;&quot;&quot;Accept arguments to define our box, and store them.&quot;&quot;&quot;
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.stretchy = stretchy

    def __repr__(self):
        return 'Box(%s, %s, %s, %s)' % (self.x, self.y, self.w, self.y)


# Many boxes with varying widths, and about 1 in 10 will be stretchy
from random import randint

many_boxes = [
    Box(w=1 + randint(-5, 5) / 10, stretchy=(randint(0, 5) == 4))
    for i in range(5000)
]
# A few pages all the same size
pages = [Box(i * 35, 0, 30, 50) for i in range(10)]

</code></pre>
<p>The changes in the layout function are not so big.</p>
<pre><code class="language-python"># lesson6.py
# We add a &quot;separation&quot; constant so you can see the boxes individually
separation = .2


def layout(_boxes):
    # Because we modify the box list, we will work on a copy
    boxes = _boxes[:]
    # We start at page 0
    page = 0
    # The 1st box should be placed in the correct page
    previous = boxes.pop(0)
    previous.x = pages[page].x
    previous.y = pages[page].y
    row = []
    while boxes:
        # We take the new 1st box
        box = boxes.pop(0)
        # And put it next to the other
        box.x = previous.x + previous.w + separation
        # At the same vertical location
        box.y = previous.y
        # But if it's too far to the right...
        if (box.x + box.w) &gt; (pages[page].x + pages[page].w):
            # We adjust the row
            slack = (pages[page].x + pages[page].w) - (
                row[-1].x + row[-1].w
            )

</code></pre>
<p>When finishing a row, see if it has stretchy boxes in it.</p>
<p>If it doesn't, bump each box a little to the right like we did before.</p>
<pre><code class="language-python"># lesson6.py
            # Get a list of all the ones that are stretchy
            stretchies = [b for b in row if b.stretchy]
            if not stretchies:  # Nothing stretches do as before.
                bump = slack / len(row)
                # The 1st box gets 0 bumps, the 2nd gets 1 and so on
                for i, b in enumerate(row):
                    b.x += bump * i

</code></pre>
<p>If we do have stretchy boxes in the row, make each one wider.</p>
<pre><code class="language-python"># lesson6.py
            else:
                bump = slack / len(stretchies)
                # Each stretchy gets wider
                for b in stretchies:
                    b.w += bump
                # And we put each thing next to the previous one
                for j, b in enumerate(row[1:], 1):
                    b.x = row[j - 1].x + row[j - 1].w + separation

</code></pre>
<p>And continue like we did before.</p>
<pre><code class="language-python"># lesson6.py
            # We start a new row
            row = []
            # We go all the way left and a little down
            box.x = pages[page].x
            box.y = previous.y + previous.h + separation

        # But if we go too far down
        if box.y + box.h &gt; pages[page].y + pages[page].h:
            # We go to the next page
            page += 1
            # And put the box at the top-left
            box.x = pages[page].x
            box.y = pages[page].y

        # Put the box in the row
        row.append(box)
        previous = box


layout(many_boxes)

</code></pre>
<p>The drawing code needs a change so we can see the &quot;stretchy&quot; boxes in a different color.</p>
<pre><code class="language-python"># lesson6.py
import svgwrite


def draw_boxes(boxes, fname, size):
    dwg = svgwrite.Drawing(fname, profile='full', size=size)
    # Draw the pages
    for page in pages:
        dwg.add(
            dwg.rect(
                insert=(page.x, page.y),
                size=(page.w, page.h),
                fill='lightblue',
            )
        )
    # Draw all the boxes
    for box in boxes:
        # The box color depends on its features
        color = 'green' if box.stretchy else 'red'
        dwg.add(
            dwg.rect(
                insert=(box.x, box.y), size=(box.w, box.h), fill=color
            )
        )
    dwg.save()


draw_boxes(many_boxes, 'lesson6.svg', (100, 50))

</code></pre>
<p><img src="part1/lesson6.svg" alt="lesson6.svg" /></p>
<p>This layout strategy works:</p>
<ul>
<li>With multiple pages of arbitrary sizes and positions</li>
<li>With many boxes of different widths and stretch capabilities</li>
<li>Even if nothing can stretch</li>
</ul>
<p>But the next lesson will start taking things to the next level.</p>
<hr />
<p>Further references:</p>
<ul>
<li>Full source code for this lesson <a href="lesson6.py.run.html">lesson6.py</a></li>
<li><a href="part1/code/diffs/lesson5_lesson6.html">Difference with code from last lesson</a></li>
</ul>
<a class="header" href="print.html#boxes-v07" id="boxes-v07"><h1>BOXES v0.7</h1></a>
<p>So far in our previous lessons we have worked in an abstract world of boxes.
Some hints of a direction were visible, like organizing our boxes in <em>pages</em> and trying to achieve a <em>justified layout</em> among others.</p>
<p>So, let's just say it, we are going to be doing text layout. But not the easy one. No, sir. No monospaced fonts for us. We want to do the whole enchilada, we are going to have variable-width fonts with kerning, and multi-page, fully-justified text layouts <strong>with hyphenation</strong>.</p>
<p>Ok, perhaps about 50% of the enchilada, because it will have no bidirectional support, only wok in english, only read UTF-8 encoded files, and so on a lot of things. But it's still a lot of mexican food!</p>
<p>And we are going to do that in lessons not much longer than the ones you have been seeing so far. Except this one. This one is much longer. So let's get started.</p>
<p>Clearly, we want our boxes to have letters. And our &quot;stretchy&quot; boxes are special because they have things like spaces. In fact, let's just say they have spaces.</p>
<p>We will now expand our Box class to support letters inside the boxes.</p>
<pre><code class="language-python"># lesson7.py
class Box():

    def __init__(self, x=0, y=0, w=1, h=1, stretchy=False, letter='x'):
        &quot;&quot;&quot;Accept arguments to define our box, and store them.&quot;&quot;&quot;
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.stretchy = stretchy
        self.letter = letter

    def __repr__(self):
        return 'Box(%s, %s, %s, %s, &quot;%s&quot;)' % (
            self.x, self.y, self.w, self.y, self.letter
        )


# Many boxes, all the same width, with an x in them
text_boxes = [Box() for i in range(5000)]

# A few pages all the same size
pages = [Box(i * 35, 0, 30, 50) for i in range(10)]


</code></pre>
<p>We can keep using the exact same layout function.</p>
<pre><code class="language-python"># lesson7.py
# We add a &quot;separation&quot; constant so you can see the boxes individually
separation = .05


def layout(_boxes):
    # Because we modify the box list, we will work on a copy
    boxes = _boxes[:]
    # We start at page 0
    page = 0
    # The 1st box should be placed in the correct page
    previous = boxes.pop(0)
    previous.x = pages[page].x
    previous.y = pages[page].y
    row = []
    while boxes:
        # We take the new 1st box
        box = boxes.pop(0)
        # And put it next to the other
        box.x = previous.x + previous.w + separation
        # At the same vertical location
        box.y = previous.y
        # But if it's too far to the right...
        if (box.x + box.w) &gt; (pages[page].x + pages[page].w):
            # We adjust the row
            slack = (pages[page].x + pages[page].w) - (
                row[-1].x + row[-1].w
            )
            # Get a list of all the ones that are stretchy
            stretchies = [b for b in row if b.stretchy]
            if not stretchies:  # Nothing stretches do as before.
                bump = slack / len(row)
                # The 1st box gets 0 bumps, the 2nd gets 1 and so on
                for i, b in enumerate(row):
                    b.x += bump * i
            else:
                bump = slack / len(stretchies)
                # Each stretchy gets wider
                for b in stretchies:
                    b.w += bump
                # And we put each thing next to the previous one
                for j, b in enumerate(row[1:], 1):
                    b.x = row[j - 1].x + row[j - 1].w + separation


            # We start a new row
            row = []
            # We go all the way left and a little down
            box.x = pages[page].x
            box.y = previous.y + previous.h + separation

        # But if we go too far down
        if box.y + box.h &gt; pages[page].y + pages[page].h:
            # We go to the next page
            page += 1
            # And put the box at the top-left
            box.x = pages[page].x
            box.y = pages[page].y

        # Put the box in the row
        row.append(box)
        previous = box


layout(text_boxes)

</code></pre>
<p>And tweak the drawing function to show us letters, and to make the colored boxes optional.</p>
<pre><code class="language-python"># lesson7.py
import svgwrite


def draw_boxes(boxes, fname, size, hide_boxes=False):
    dwg = svgwrite.Drawing(fname, profile='full', size=size)
    # Draw the pages
    for page in pages:
        dwg.add(
            dwg.rect(
                insert=(page.x, page.y),
                size=(page.w, page.h),
                fill='lightblue',
            )
        )
    # Draw all the boxes
    for box in boxes:
        # The box color depends on its features
        color = 'green' if box.stretchy else 'red'
        # Make the colored boxes optional
        if not hide_boxes:
            dwg.add(
                dwg.rect(
                    insert=(box.x, box.y),
                    size=(box.w, box.h),
                    fill=color,
                )
            )
        # Display the letter in the box
        if box.letter:
            dwg.add(
                dwg.text(
                    box.letter,
                    insert=(box.x, box.y + box.h),
                    font_size=box.h,
                    font_family='Arial',
                )
            )
    dwg.save()


draw_boxes(text_boxes, 'lesson7.svg', (30, 20))

</code></pre>
<p><img src="part1/lesson7.svg" alt="lesson7.svg" /></p>
<p>Of course this is very boring, so we need to spice up our data a little.
We can use different letters, and then make the right ones stretchy. That is easy!</p>
<pre><code class="language-python"># lesson7.py
from random import choice

for box in text_boxes:
    # More than one space so they appear often
    box.letter = choice('     abcdefghijklmnopqrstuvwxyz')
    if box.letter == ' ':  # Spaces are stretchy
        box.stretchy = True

layout(text_boxes)
draw_boxes(text_boxes, 'lesson7_different_letters.svg', (30, 20))

</code></pre>
<p><img src="part1/lesson7_different_letters.svg" alt="lesson7_different_letters.svg" /></p>
<p>As you can see, there are very minor horizontal shifts and stretches, since all boxes are the same size.</p>
<p>But as a text layout engine we have a <strong>major</strong> failure: we are ignoring the size of the letters we are layouting!</p>
<p>This is a very complex thing to do called <em>text shaping</em>. You need to understand the content of the font you are using to display the text, and more subtle things like what happens if you put specific letters next to each other (kerning) and much more.</p>
<p>The good news is that it's already done for us, in libraries called Harfbuzz and Freetype.</p>
<p>This paragraph is perhaps the most important one in this book. I am about to show you some obscure code. And I will tell you the secret of how it got here:
<strong>I copied it from the documentation for the libraries I am using.</strong> Sometimes you will need to do something complicated only once in your life. It's perfectly ok to just google how to do it. And as long as you are confident you can find it again if needed, it's ok to just forget about it.</p>
<p>I will show you this code, and then put it in a separate file called <code>fonts.py</code> and from now on I will not show it in the lessons, because we are <em>not</em> going to change it, <em>ever</em>.</p>
<pre><code class="language-python"># fonts.py
import harfbuzz as hb
import freetype2 as ft


def adjust_widths_by_letter(boxes):
    &quot;&quot;&quot;Takes a list of boxes as arguments, and uses harfbuzz to
    adjust the width of each box to match the harfbuzz text shaping.&quot;&quot;&quot;
    buf = hb.Buffer.create()
    buf.add_str(''.join(b.letter for b in boxes))
    buf.guess_segment_properties()
    font_lib = ft.get_default_lib()
    face = font_lib.find_face('Arial')
    face.set_char_size(size=1, resolution=64)
    font = hb.Font.ft_create(face)
    hb.shape(font, buf)
    # at this point buf.glyph_positions has all the data we need
    for box, position in zip(boxes, buf.glyph_positions):
        box.w = position.x_advance

</code></pre>
<p>And now we will pretend we know what that does, based on its docstring and use it.</p>
<pre><code class="language-python"># lesson7.py
from code import fonts


separation = .05
fonts.adjust_widths_by_letter(text_boxes)
layout(text_boxes)
draw_boxes(text_boxes, 'lesson7_adjusted_letters.svg', (30, 20))

</code></pre>
<p><img src="part1/lesson7_adjusted_letters.svg" alt="lesson7_adjusted_letters.svg" /></p>
<p>And nicer, without the boxes:</p>
<pre><code class="language-python"># lesson7.py
fonts.adjust_widths_by_letter(text_boxes)
layout(text_boxes)
draw_boxes(
    text_boxes,
    'lesson7_adjusted_letters_no_boxes.svg',
    (30, 20),
    hide_boxes=True,
)

</code></pre>
<p><img src="part1/lesson7_adjusted_letters_no_boxes.svg" alt="lesson7_adjusted_letters_no_boxes.svg" /></p>
<p>And of course, we can just load text there instead of random letters. For example, here we load what is going to be our example test from now on,
Jane Austen's <a href="http://www.gutenberg.org/ebooks/1342">Pride and Prejudice from Project Gutenberg</a></p>
<pre><code class="language-python"># lesson7.py
p_and_p = open('pride-and-prejudice.txt').read()
text_boxes = []
for l in p_and_p:
    text_boxes.append(Box(letter=l, stretchy=l == ' '))
fonts.adjust_widths_by_letter(text_boxes)
layout(text_boxes)
draw_boxes(
    text_boxes,
    'lesson7_pride_and_prejudice.svg',
    (30, 20),
    hide_boxes=True,
)

</code></pre>
<p><img src="part1/lesson7_pride_and_prejudice.svg" alt="lesson7_pride_and_prejudice.svg" /></p>
<p>And that is ... maybe disappointing? While we spent a lot of time on things like justifying text, we have not even looked at newlines!</p>
<p>Also, spaces at the end of lines make the line appear ragged again, now that they are not boxes.</p>
<p>So, we know what to hit in the next lesson.</p>
<hr />
<p>Further references:</p>
<ul>
<li>Full source code for this lesson <a href="lesson7.py.run.html">lesson7.py</a></li>
<li><a href="part1/code/diffs/lesson6_lesson7.html">Difference with code from last lesson</a></li>
</ul>
<a class="header" href="print.html#boxes-v08" id="boxes-v08"><h1>BOXES v0.8</h1></a>
<p>In the <a href="lesson7.run.html">previous lesson</a> we started using our layout engine to display text, and ran into some limitations. Let's get rid of them.</p>
<p>We have no changes in our Box class, or the page setup, or how we load and adjust the boxes' sizes.</p>
<pre><code class="language-python"># lesson8.py
from code.fonts import adjust_widths_by_letter


class Box():

    def __init__(self, x=0, y=0, w=1, h=1, stretchy=False, letter='x'):
        &quot;&quot;&quot;Accept arguments to define our box, and store them.&quot;&quot;&quot;
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.stretchy = stretchy
        self.letter = letter

    def __repr__(self):
        return 'Box(%s, %s, %s, %s, &quot;%s&quot;)' % (
            self.x, self.y, self.w, self.y, self.letter
        )


p_and_p = open('pride-and-prejudice.txt').read()
text_boxes = []
for l in p_and_p:
    text_boxes.append(Box(letter=l, stretchy=l == ' '))
adjust_widths_by_letter(text_boxes)

# A few pages all the same size
pages = [Box(i * 35, 0, 30, 50) for i in range(10)]

</code></pre>
<p>Also unchanged is the drawing code.</p>
<pre><code class="language-python"># lesson8.py

import svgwrite


def draw_boxes(boxes, fname, size, hide_boxes=False):
    dwg = svgwrite.Drawing(fname, profile='full', size=size)
    # Draw the pages
    for page in pages:
        dwg.add(
            dwg.rect(
                insert=(page.x, page.y),
                size=(page.w, page.h),
                fill='lightblue',
            )
        )
    # Draw all the boxes
    for box in boxes:
        # The box color depends on its features
        color = 'green' if box.stretchy else 'red'
        # Make the colored boxes optional
        if not hide_boxes:
            dwg.add(
                dwg.rect(
                    insert=(box.x, box.y),
                    size=(box.w, box.h),
                    fill=color,
                )
            )
        # Display the letter in the box
        if box.letter:
            dwg.add(
                dwg.text(
                    box.letter,
                    insert=(box.x, box.y + box.h),
                    font_size=box.h,
                    font_family='Arial',
                )
            )
    dwg.save()

</code></pre>
<p>But we need to work on our layout engine, a lot. Here is the image of our attempt at displaying &quot;Pride and Prejudice&quot;:</p>
<p><img src="part1/lesson7_pride_and_prejudice.svg" alt="lesson7_pride_and_prejudice.svg" /></p>
<p>Let's count the problems:</p>
<ol>
<li>It totally ignores newlines everywhere</li>
<li>It keeps spaces at the end of rows, making the right side ragged
(see &quot;said his &quot; in the seventh line)</li>
<li>White space at the beginning of rows is shown and it looks bad
(see &quot; a neigh&quot; at the beginning of the fifth line)</li>
<li>Words are split between lines haphazardly, but this is for later and leads
to some serious code that needs its own lesson.</li>
</ol>
<p>Let's hit the issues in order. First, newlines.</p>
<p>The idea is: if we find a newline, we need to break the line. Doesn't sound
particularly complex, specially since lines that are broken intentionally
are never fully justified.</p>
<p>The changes are minor:</p>
<ul>
<li>Create a flag <code>break_line</code> set to True if we encounter a newline
or overflow the page.</li>
<li>In case of newline, make that box invisible by making it 0-wide and
not stretchy.</li>
<li>When the break_line flag is set, handle as usual by moving to the
left, etc.</li>
</ul>
<pre><code class="language-python"># lesson8.py
# We add a &quot;separation&quot; constant so you can see the boxes individually
separation = .05


def layout(_boxes):
    # Because we modify the box list, we will work on a copy
    boxes = _boxes[:]
    # We start at page 0
    page = 0
    # The 1st box should be placed in the correct page
    previous = boxes.pop(0)
    previous.x = pages[page].x
    previous.y = pages[page].y
    row = []
    while boxes:
        # We take the new 1st box
        box = boxes.pop(0)
        # And put it next to the other
        box.x = previous.x + previous.w + separation
        # At the same vertical location
        box.y = previous.y

        # Handle breaking on newlines
        break_line = False
        # But if it's a newline
        if (box.letter == '\n'):
            break_line = True
            # Newlines take no horizontal space ever
            box.w = 0
            box.stretchy = False

        # Or if it's too far to the right...
        elif (box.x + box.w) &gt; (pages[page].x + pages[page].w):
            break_line = True
            # We adjust the row
            slack = (pages[page].x + pages[page].w) - (
                row[-1].x + row[-1].w
            )
            # Get a list of all the ones that are stretchy
            stretchies = [b for b in row if b.stretchy]
            if not stretchies:  # Nothing stretches do as before.
                bump = slack / len(row)
                # The 1st box gets 0 bumps, the 2nd gets 1 and so on
                for i, b in enumerate(row):
                    b.x += bump * i
            else:
                bump = slack / len(stretchies)
                # Each stretchy gets wider
                for b in stretchies:
                    b.w += bump
                # And we put each thing next to the previous one
                for j, b in enumerate(row[1:], 1):
                    b.x = row[j - 1].x + row[j - 1].w + separation


        if break_line:
            # We start a new row
            row = []
            # We go all the way left and a little down
            box.x = pages[page].x
            box.y = previous.y + previous.h + separation

        # But if we go too far down
        if box.y + box.h &gt; pages[page].y + pages[page].h:
            # We go to the next page
            page += 1
            # And put the box at the top-left
            box.x = pages[page].x
            box.y = pages[page].y

        # Put the box in the row
        row.append(box)
        previous = box


layout(text_boxes)

</code></pre>
<p>The code changes are small, but the output now looks radically different.</p>
<pre><code class="language-python"># lesson8.py
draw_boxes(text_boxes, 'lesson8.svg', (30, 50), hide_boxes=True)

</code></pre>
<p><img src="part1/lesson8.svg" alt="lesson8.svg" /></p>
<hr />
<p>Further references:</p>
<ul>
<li>Full source code for this lesson <a href="lesson8.py.run.html">lesson8.py</a></li>
<li><a href="part1/code/diffs/lesson7_lesson8.html">Difference with code from last lesson</a></li>
</ul>
<a class="header" href="print.html#boxes-v09" id="boxes-v09"><h1>BOXES v0.9</h1></a>
<p>In the <a href="lesson8.run.html">previous lesson</a> we fixed the handling of newlines
in our layout engine, and noticed a problem with spaces. Let's fix it!</p>
<p>We have no changes in our Box class, or the page setup, or how we load and adjust the boxes' sizes.</p>
<pre><code class="language-python"># lesson9.py
from code.fonts import adjust_widths_by_letter


class Box():

    def __init__(self, x=0, y=0, w=1, h=1, stretchy=False, letter='x'):
        &quot;&quot;&quot;Accept arguments to define our box, and store them.&quot;&quot;&quot;
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.stretchy = stretchy
        self.letter = letter

    def __repr__(self):
        return 'Box(%s, %s, %s, %s, &quot;%s&quot;)' % (
            self.x, self.y, self.w, self.y, self.letter
        )


p_and_p = open('pride-and-prejudice.txt').read()
text_boxes = []
for l in p_and_p:
    text_boxes.append(Box(letter=l, stretchy=l == ' '))
adjust_widths_by_letter(text_boxes)

# A few pages all the same size
pages = [Box(i * 35, 0, 30, 50) for i in range(10)]

</code></pre>
<p>Also unchanged is the drawing code.</p>
<pre><code class="language-python"># lesson9.py
import svgwrite


def draw_boxes(boxes, fname, size, hide_boxes=False):
    dwg = svgwrite.Drawing(fname, profile='full', size=size)
    # Draw the pages
    for page in pages:
        dwg.add(
            dwg.rect(
                insert=(page.x, page.y),
                size=(page.w, page.h),
                fill='lightblue',
            )
        )
    # Draw all the boxes
    for box in boxes:
        # The box color depends on its features
        color = 'green' if box.stretchy else 'red'
        # Make the colored boxes optional
        if not hide_boxes:
            dwg.add(
                dwg.rect(
                    insert=(box.x, box.y),
                    size=(box.w, box.h),
                    fill=color,
                )
            )
        # Display the letter in the box
        if box.letter:
            dwg.add(
                dwg.text(
                    box.letter,
                    insert=(box.x, box.y + box.h),
                    font_size=box.h,
                    font_family='Arial',
                )
            )
    dwg.save()

</code></pre>
<p>The more obvious problems are:</p>
<ul>
<li>It keeps spaces at the end of rows, making the right side ragged.</li>
<li>White space at the beginning of rows is shown and it looks bad</li>
</ul>
<p><img src="part1/lesson8.svg" alt="lesson8.svg" /></p>
<p>You can see clearly, in the previous sample output where this happens in one of the latter paragraphs, &quot;to see the place,  &quot; appears ragged when it should not. And a similar thing happens in an earlier paragraph where there is a hole against the left margin in &quot; told me all about it&quot;.</p>
<p>In both cases, the cause is because the &quot;empty&quot; space is used by spaces!</p>
<p>So, one possible solution is, when justifying a row, to make all the spaces at the right margins 0-width and not stretchy. At the same time, when adding spaces at the beginning of a row, they should become 0-width and not stretchy.</p>
<p><strong>BUT</strong> this means the list of boxes will need its width readjusted if they are to be layouted again on different pages! That's because some of the spaces will now be thin and &quot;rigid&quot; so they will work badly if they are <strong>not</strong> against the margin on a different layout.</p>
<p>It's not a big problem, but it's worth keeping in mind, since it's the kind of thing that becomes an obscure bug later on. So, we add it to the docstring.</p>
<pre><code class="language-python"># lesson9.py
# We add a &quot;separation&quot; constant so you can see the boxes individually
separation = .05


def layout(_boxes):
    &quot;&quot;&quot;Layout boxes along pages.

    Keep in mind that this function modifies the boxes themselves, so
    you should be very careful about trying to call layout() more than once
    on the same boxes.

    Specifically, some spaces will become 0-width and not stretchy.
    &quot;&quot;&quot;

    # Because we modify the box list, we will work on a copy
    boxes = _boxes[:]
    # We start at page 0
    page = 0
    # The 1st box should be placed in the correct page
    previous = boxes.pop(0)
    previous.x = pages[page].x
    previous.y = pages[page].y
    row = []
    while boxes:
        # We take the new 1st box
        box = boxes.pop(0)
        # And put it next to the other
        box.x = previous.x + previous.w + separation
        # At the same vertical location
        box.y = previous.y

        # Handle breaking on newlines
        break_line = False
        # But if it's a newline
        if (box.letter == '\n'):
            break_line = True
            # Newlines take no horizontal space ever
            box.w = 0
            box.stretchy = False

        # Or if it's too far to the right...
        elif (box.x + box.w) &gt; (pages[page].x + pages[page].w):
            break_line = True
            # We adjust the row
            # Remove all right-margin spaces
            while row[-1].letter == ' ':
                row.pop()
            slack = (pages[page].x + pages[page].w) - (
                row[-1].x + row[-1].w
            )
            # Get a list of all the ones that are stretchy
            stretchies = [b for b in row if b.stretchy]
            if not stretchies:  # Nothing stretches do as before.
                bump = slack / len(row)
                # The 1st box gets 0 bumps, the 2nd gets 1 and so on
                for i, b in enumerate(row):
                    b.x += bump * i
            else:
                bump = slack / len(stretchies)
                # Each stretchy gets wider
                for b in stretchies:
                    b.w += bump
                # And we put each thing next to the previous one
                for j, b in enumerate(row[1:], 1):
                    b.x = row[j - 1].x + row[j - 1].w + separation


        if break_line:
            # We start a new row
            row = []
            # We go all the way left and a little down
            box.x = pages[page].x
            box.y = previous.y + previous.h + separation

        # But if we go too far down
        if box.y + box.h &gt; pages[page].y + pages[page].h:
            # We go to the next page
            page += 1
            # And put the box at the top-left
            box.x = pages[page].x
            box.y = pages[page].y

        # Put the box in the row
        row.append(box)

        # Collapse all left-margin space
        if all(b.letter == ' ' for b in row):
            box.w = 0
            box.stretchy = False
            box.x = pages[page].x

        previous = box


layout(text_boxes)

</code></pre>
<pre><code class="language-python"># lesson9.py
draw_boxes(text_boxes, 'lesson9.svg', (30, 50), hide_boxes=True)

</code></pre>
<p><img src="part1/lesson9.svg" alt="lesson9.svg" /></p>
<p>As you can see, the justification now is absolutely tight where it needs to be.
With that taken care of, we will consider the problem of breaking lines inside words and how to fix it using hyphenation in the next lesson.</p>
<hr />
<p>Further references:</p>
<ul>
<li>Full source code for this lesson <a href="lesson9.py.run.html">lesson9.py</a></li>
<li><a href="part1/code/diffs/lesson8_lesson9.html">Difference with code from last lesson</a></li>
</ul>
<a class="header" href="print.html#boxes-v010" id="boxes-v010"><h1>BOXES v0.10</h1></a>
<p>In our <a href="lesson9.run.html">previous lesson</a> we created a serviceable text
layout engine. It has many problems, but remember our goal is not to create
the best possible thing, this is an educational experience. The spit and
polish will appear later on.</p>
<p>But there is a glaring problem, it breaks words in all the wrong places.
Examples of it appear in almost every line of the output. So, how does one fix
that?</p>
<p>The traditional answer (and the one we will be using) is hyphenation, breaking
words between lines in the correct places.</p>
<p>Instead of breaking anywhere, we will break only in the places where the <a href="https://english.stackexchange.com/questions/385/what-are-the-rules-for-splitting-words-at-the-end-of-a-line">rules of each language</a>
allow us to.</p>
<p>Just as it happened with <a href="lesson7.run.html">text shaping</a> we are lucky to live
in a moment in time when almost everything we need to do it right is already
in place. In particular, we will use a library called <a href="https://github.com/Kozea/Pyphen">Pyphen</a>
mostly because I already have used it in another project.</p>
<p>Am I sure it's the best one? No. Do I know exactly how it does what it does?
No. I know enough to make it work, and it works <em>well enough</em> so for this
stage in the life of this project that is more than enough. In fact, it takes
the rules for word-breaking from dictionaries provided by an Office Suite, so
it does about as good a job as the dictionary does. It even supports
subtleties such as the differences between British and American English!</p>
<p>Here's an example of how it works:</p>
<pre><code class="language-python">import pyphen
dic = pyphen.Pyphen(lang='en_GB')
print('en_GB:', dic.inserted('dictionary', '-'))
dic = pyphen.Pyphen(lang='en_US')
print('en_US:', dic.inserted('dictionary', '-'))
</code></pre>
<pre><code>en_GB: dic-tion-ary
en_US: dic-tio-nary
</code></pre>
<p>Keep in mind that this is not magic. If you feed it garbage, it will give you
garbage.</p>
<pre><code class="language-python">dic = pyphen.Pyphen(lang='es_ES')
print('es_ES:', dic.inserted('dictionary', '-'))
</code></pre>
<pre><code>es_ES: dic-tio-na-ry
</code></pre>
<p>Where is it proper to break a line?</p>
<ul>
<li>On a newline character</li>
<li>On a space</li>
<li>On a breaking point as defined by Pyphen</li>
</ul>
<p>One of those things is not like the others. We have boxes with newlines in
them and we have boxes with spaces in them, but there are no boxes with
breaking points in them.</p>
<p>But we can add them! There is Unicode symbol for that:</p>
<blockquote>
<a class="header" href="print.html#soft-hyphen-shy" id="soft-hyphen-shy"><h3>SOFT HYPHEN (SHY)</h3></a>
<p>The <a href="https://en.wikipedia.org/wiki/Soft_hyphen">soft hyphen</a> serves as an
invisible marker used to specify a place in text where a hyphenated break
is allowed without forcing a line break in an inconvenient place if the
text is re-flowed. It becomes visible only after word wrapping at the end
of a line.</p>
</blockquote>
<p>So, if we insert them in all the right places, then we can use them to decide
whether we are at a suitable breaking point. We will put this in a file called
<code>hyphen.py</code></p>
<pre><code class="language-python"># hyphen.py
import pyphen

dic = pyphen.Pyphen(lang='en_US')


def insert_soft_hyphens(text, hyphen='\xad'):
    &quot;&quot;&quot;Insert the hyphen in breaking pointsaccording to the dictionary.
    
    '\xad' is the Soft Hyphen (SHY) character
    &quot;&quot;&quot;
    lines = []
    for line in text.splitlines():
        hyph_words = [
            dic.inserted(word, hyphen) for word in line.split()
        ]
        lines.append(' '.join(hyph_words))
    return '\n'.join(lines)

</code></pre>
<pre><code class="language-python">from code.hyphen import insert_soft_hyphens

print (insert_soft_hyphens('Roses are red\nViolets are blue', '-'))
</code></pre>
<pre><code>Ros-es are red
Vi-o-lets are blue
</code></pre>
<p>So, with this code ready, we can get to work on implementing hyphenation
support in our layout function.</p>
<p>First, this code is exactly as it was before:</p>
<pre><code class="language-python"># lesson10.py
from code.fonts import adjust_widths_by_letter
from code.hyphen import insert_soft_hyphens


class Box():

    def __init__(self, x=0, y=0, w=1, h=1, stretchy=False, letter='x'):
        &quot;&quot;&quot;Accept arguments to define our box, and store them.&quot;&quot;&quot;
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.stretchy = stretchy
        self.letter = letter

    def __repr__(self):
        return 'Box(%s, %s, %s, %s, &quot;%s&quot;)' % (
            self.x, self.y, self.w, self.y, self.letter
        )

</code></pre>
<p>We do need to make a small change to how we load our text, to add the hyphens:</p>
<pre><code class="language-python"># lesson10.py
p_and_p = open('pride-and-prejudice.txt').read()
p_and_p = insert_soft_hyphens(p_and_p)  # Insert invisible hyphens
text_boxes = []
for l in p_and_p:
    text_boxes.append(Box(letter=l, stretchy=l == ' '))
adjust_widths_by_letter(text_boxes)

# A few pages all the same size
pages = [Box(i * 35, 0, 30, 50) for i in range(10)]

</code></pre>
<p>No changes in how we draw things.</p>
<pre><code class="language-python"># lesson10.py
import svgwrite


def draw_boxes(boxes, fname, size, hide_boxes=False):
    dwg = svgwrite.Drawing(fname, profile='full', size=size)
    # Draw the pages
    for page in pages:
        dwg.add(
            dwg.rect(
                insert=(page.x, page.y),
                size=(page.w, page.h),
                fill='lightblue',
            )
        )
    # Draw all the boxes
    for box in boxes:
        # The box color depends on its features
        color = 'green' if box.stretchy else 'red'
        # Make the colored boxes optional
        if not hide_boxes:
            dwg.add(
                dwg.rect(
                    insert=(box.x, box.y),
                    size=(box.w, box.h),
                    fill=color,
                )
            )
        # Display the letter in the box
        if box.letter:
            dwg.add(
                dwg.text(
                    box.letter,
                    insert=(box.x, box.y + box.h),
                    font_size=box.h,
                    font_family='Arial',
                )
            )
    dwg.save()

</code></pre>
<p>And now our layout function. One first approach, which we will refine later,
is to simply refuse to break lines if we are not in a &quot;good&quot; place to break it.</p>
<p>Then, we inject a box with a visible hyphen in the line break, and that's it.</p>
<p>Here is the code to create a box with a hyphen:</p>
<pre><code class="language-python"># lesson10.py
def hyphenbox():
    b = Box(letter='-')
    adjust_widths_by_letter([b])
    return b

</code></pre>
<p>And here finally, our layout supports hyphens:</p>
<pre><code class="language-python"># lesson10.py
# We add a &quot;separation&quot; constant so you can see the boxes individually
separation = .05


def layout(_boxes):
    &quot;&quot;&quot;Layout boxes along pages.

    Keep in mind that this function modifies the boxes themselves, so
    you should be very careful about trying to call layout() more than once
    on the same boxes.

    Specifically, some spaces will become 0-width and not stretchy.
    &quot;&quot;&quot;

    # Because we modify the box list, we will work on a copy
    boxes = _boxes[:]
    # We start at page 0
    page = 0
    # The 1st box should be placed in the correct page
    previous = boxes.pop(0)
    previous.x = pages[page].x
    previous.y = pages[page].y
    row = []
    while boxes:
        # We take the new 1st box
        box = boxes.pop(0)
        # And put it next to the other
        box.x = previous.x + previous.w + separation
        # At the same vertical location
        box.y = previous.y

        # Handle breaking on newlines
        break_line = False
        # But if it's a newline
        if (box.letter == '\n'):
            break_line = True
            # Newlines take no horizontal space ever
            box.w = 0
            box.stretchy = False

        # Or if it's too far to the right, and is a
        # good place to break the line...
        elif (box.x + box.w) &gt; (
            pages[page].x + pages[page].w
        ) and box.letter in (
            ' ', '\xad'
        ):
            if box.letter == '\xad':
                # Add a visible hyphen in the row
                h_b = hyphenbox()
                h_b.x = previous.x + previous.w + separation
                h_b.y = previous.y
                _boxes.append(h_b)  # So it's drawn
                row.append(h_b)  # So it's justified
            break_line = True
            # We adjust the row
            # Remove all right-margin spaces
            while row[-1].letter == ' ':
                row.pop()
            slack = (pages[page].x + pages[page].w) - (
                row[-1].x + row[-1].w
            )
            # Get a list of all the ones that are stretchy
            stretchies = [b for b in row if b.stretchy]
            if not stretchies:  # Nothing stretches do as before.
                bump = slack / len(row)
                # The 1st box gets 0 bumps, the 2nd gets 1 and so on
                for i, b in enumerate(row):
                    b.x += bump * i
            else:
                bump = slack / len(stretchies)
                # Each stretchy gets wider
                for b in stretchies:
                    b.w += bump
                # And we put each thing next to the previous one
                for j, b in enumerate(row[1:], 1):
                    b.x = row[j - 1].x + row[j - 1].w + separation


        if break_line:
            # We start a new row
            row = []
            # We go all the way left and a little down
            box.x = pages[page].x
            box.y = previous.y + previous.h + separation

        # But if we go too far down
        if box.y + box.h &gt; pages[page].y + pages[page].h:
            # We go to the next page
            page += 1
            # And put the box at the top-left
            box.x = pages[page].x
            box.y = pages[page].y

        # Put the box in the row
        row.append(box)

        # Collapse all left-margin space
        if all(b.letter == ' ' for b in row):
            box.w = 0
            box.stretchy = False
            box.x = pages[page].x

        previous = box


layout(text_boxes)

</code></pre>
<pre><code class="language-python"># lesson10.py
draw_boxes(text_boxes, 'lesson10.svg', (30, 50), hide_boxes=True)

</code></pre>
<p><img src="part1/lesson10.svg" alt="lesson10.svg" /></p>
<p>And there in &quot;proper-ty&quot; you can see it in action. Of course this is
a naïve implementation. What happens if you just can't break?</p>
<pre><code class="language-python">many_boxes = [Box(letter='a') for i in range(200)]
adjust_widths_by_letter(many_boxes)
layout(many_boxes)
draw_boxes(many_boxes, 'lesson10_lots_of_a.svg', (35, 6), hide_boxes=True)
</code></pre>
<p><img src="part1/lesson10_lots_of_a.svg" alt="lesson10_lots_of_a.svg" /></p>
<p>Since it can't break at all, it just goes on and on.</p>
<p>And there are other corner cases!</p>
<pre><code class="language-python">many_boxes = [Box(letter='a') for i in range(200)]
many_boxes[100] = Box(letter=' ', stretchy=True)
adjust_widths_by_letter(many_boxes)
layout(many_boxes)
draw_boxes(many_boxes, 'lesson10_one_break.svg', (35, 6), hide_boxes=True)
</code></pre>
<p><img src="part1/lesson10_one_break.svg" alt="lesson10_one_break.svg" /></p>
<p>Because there is only one place to break the line, it then tries to
wedge 100 letter &quot;a&quot; where there is room for 54 (I counted!) and something interesting happens... the &quot;slack&quot; is negative!</p>
<p>Instead of stretching out a &quot;underfilled&quot; line, we are squeezing a &quot;overfilled&quot; one. Everything gets packed too tight, and the letters start
overlapping one another.</p>
<p>The lesson is that just because it works for the usual case it doesn't mean
it's <strong>done</strong>. Even in the case of words, it can happen that breaking points take a while to appear and our line becomes overfull.</p>
<p>We will tackle that problem next.</p>
<hr />
<p>Further references:</p>
<ul>
<li>Full source code for this lesson <a href="lesson10.py.run.html">lesson10.py</a></li>
<li><a href="part1/code/diffs/lesson9_lesson10.html">Difference with code from last lesson</a></li>
</ul>
<a class="header" href="print.html#boxes-v011" id="boxes-v011"><h1>BOXES v0.11</h1></a>
<p>In our <a href="lesson10.run.html">previous lesson</a> we promised we will improve the
problem of overfull lines in our text layout engine.</p>
<p>The problem: A long string of letters without any hyphenation points or spaces
causes a very long row to be fitted into a smaller page, causing letters to
overlap. Or, if we are unable to break at all, we just spill to the right
forever.</p>
<blockquote>
<a class="header" href="print.html#underfull-and-overfull" id="underfull-and-overfull"><h3>Underfull and Overfull</h3></a>
<p>When a line has too few characters, slack is
positive and we have to &quot;spread&quot; them, that is called <strong>underfull</strong>. The
opposite, where a line has too many characters, slack is negative and we
have to &quot;smush&quot; them, is called <strong>overfull</strong>.</p>
</blockquote>
<p><img src="part1/lesson10_one_break.svg" alt="lesson10_one_break.svg" /></p>
<p>As you probably expected... no changes in the Box class.</p>
<pre><code class="language-python"># lesson11.py
from code.fonts import adjust_widths_by_letter
from code.hyphen import insert_soft_hyphens


class Box():

    def __init__(self, x=0, y=0, w=1, h=1, stretchy=False, letter='x'):
        &quot;&quot;&quot;Accept arguments to define our box, and store them.&quot;&quot;&quot;
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.stretchy = stretchy
        self.letter = letter

    def __repr__(self):
        return 'Box(%s, %s, %s, %s, &quot;%s&quot;)' % (
            self.x, self.y, self.w, self.y, self.letter
        )


# Three runs of &quot;a&quot; with spaces between them.
# The ideal breaking point is the second space.
text_boxes = [Box(letter='a') for a in range(72)]
for i in (20, 50):
    text_boxes[i].letter = ' '
    text_boxes[i].stretchy = True
adjust_widths_by_letter(text_boxes)


# A few pages all the same size
pages = [Box(i * 35, 0, 30, 50) for i in range(10)]


def hyphenbox():
    b = Box(letter='-')
    adjust_widths_by_letter([b])
    return b



</code></pre>
<p>Also no changes in how we draw things.</p>
<pre><code class="language-python"># lesson11.py
import svgwrite


def draw_boxes(boxes, fname, size, hide_boxes=False):
    dwg = svgwrite.Drawing(fname, profile='full', size=size)
    # Draw the pages
    for page in pages:
        dwg.add(
            dwg.rect(
                insert=(page.x, page.y),
                size=(page.w, page.h),
                fill='lightblue',
            )
        )
    # Draw all the boxes
    for box in boxes:
        # The box color depends on its features
        color = 'green' if box.stretchy else 'red'
        # Make the colored boxes optional
        if not hide_boxes:
            dwg.add(
                dwg.rect(
                    insert=(box.x, box.y),
                    size=(box.w, box.h),
                    fill=color,
                )
            )
        # Display the letter in the box
        if box.letter:
            dwg.add(
                dwg.text(
                    box.letter,
                    insert=(box.x, box.y + box.h),
                    font_size=box.h,
                    font_family='Arial',
                )
            )
    dwg.save()

</code></pre>
<p>So far, our algorithm to break lines is simple:</p>
<ol>
<li>If the next character is a newline: break</li>
<li>If we are short, add to the line.</li>
<li>If the next character makes the line overfull:
a. If it's a space or a hyphen: break
b. If not, add to the line</li>
<li>If we broke the line, adjust positions and widths so the line is
exactly as wide as the page by spreading the slack.</li>
</ol>
<p>We need a better way to decide what is the best possible breaking point for
the line. If it's too overfull, it will look bad. If it's too underfull, it
will look bad too. And sometimes there is just no good breaking point and we
need to <em>do something</em>.</p>
<p>If we were lucky enough to have a breaking point that exactly fills the line,
then we would not have a problem, so usually this will come down to choosing
between two breaking points. One makes the line overfull, one keeps it
underfull.</p>
<p>How good is a breaking point?</p>
<ul>
<li>If the slack is smaller, it's better.</li>
<li>If it's underfull it's slightly better than overfull, since it's better to
have a spread out line than overlapping letters.</li>
<li>If we have many spaces, then a bigger slack is acceptable.</li>
</ul>
<p>This is all subjective, of course. How much <em>movement</em> we tolerate on the text
is a judgment call, so it involves some trial and error.</p>
<p>Let's start with some made up numbers, because we have to start somewhere.</p>
<ul>
<li>The allowed positive slack is 20% of the width of the spaces in the line.</li>
<li>The allowed negative slack is 10% of the width of the spaces in the line.</li>
</ul>
<p>And here's a plan to implement it:</p>
<ul>
<li>When adding characters, check if it's a possible breaking point.</li>
<li>If it is, remember the &quot;goodness&quot; it has</li>
<li>When reaching an overfull breaking point, check if it's better than the last
one we saw.</li>
<li>If the overfull breaking point is better, break.</li>
<li>If the overfull breaking point is worse, use the underfull breaking point.</li>
</ul>
<p>The first new thing is a function to calculate how good a breaking point is,
in those terms.</p>
<pre><code class="language-python"># lesson11.py
def badness(page_width, row):
    &quot;&quot;&quot;Calculate how 'bad' a position to break is.
    
    bigger is worse.
    &quot;&quot;&quot;
    # Yes, this is suboptimal. It's easier to optimize working code
    # than fixing fast code.
    row_width = (row[-1].x + row[-1].w) - row[0].x
    slack = page_width - row_width
    stretchies = [b for b in row if b.stretchy]
    if len(stretchies) &gt; 0:
        stretchies_width = sum(s.w for s in stretchies)
        # More stetchy space is good. More slack is bad.
        badness = slack / stretchies_width
    else:  # Nothing to stretch. Not good.
        badness = 1000
    if slack &lt; 0:
        # Arbitrary fudge factor, negative slack is THIS much worse
        badness *= 2
    return badness

</code></pre>
<pre><code class="language-python"># 10 boxes of width 1, 1 stretchy in the middle
boxes = [Box(x=i, w=1) for i in range(10)]
boxes[5].stretchy = True

# On a page that is 8 units wide:
print(badness(8, boxes))
</code></pre>
<pre><code>-4.0
</code></pre>
<p>Let's see how that works for page widths between 5 and 15 (remember our row is
10 units wide):</p>
<pre><code class="language-python">for w in range(5,15):
  print('page_width:', w, ' -&gt; badness:', badness(w, boxes))
</code></pre>
<p>As you can see, if the page was 10 units wide, it would be optimal. The second
best option is for the page to be slightly wider, then maybe slightly thinner
and so on.</p>
<pre><code>page_width: 5  -&gt; badness: -10.0
page_width: 6  -&gt; badness: -8.0
page_width: 7  -&gt; badness: -6.0
page_width: 8  -&gt; badness: -4.0
page_width: 9  -&gt; badness: -2.0
page_width: 10  -&gt; badness: 0.0
page_width: 11  -&gt; badness: 1.0
page_width: 12  -&gt; badness: 2.0
page_width: 13  -&gt; badness: 3.0
page_width: 14  -&gt; badness: 4.0
</code></pre>
<p>We will need to load data that shows the problem. In this case, it's a row of
20 letters 'a' (without hyphens), a space, then 20, and then 30 more 'a's.</p>
<p>Why?</p>
<p>Like before, the page is about wide enough to fix 58 &quot;a&quot;s. That means the first
run will not be enough to fill the line. The second run will still not be
enough. The third run will, however, badly overfill it. So, we should go all
the way to the end, see that it's too long, and then go back to the second
space and break there.</p>
<pre><code class="language-python"># lesson11.py
# Three runs of &quot;a&quot; with spaces between them.
# The ideal breaking point is the second space.
text_boxes = [Box(letter='a') for a in range(72)]
for i in (20, 50):
    text_boxes[i].letter = ' '
    text_boxes[i].stretchy = True
adjust_widths_by_letter(text_boxes)


# A few pages all the same size
pages = [Box(i * 35, 0, 30, 50) for i in range(10)]

</code></pre>
<p>And now we have a problem. The change to our code needed to implement that is
too large. It's so large that it amounts to a rewrite of our layout function
and if we rewrite it, how would we be sure that we are not breaking all the
things we achieved previously?</p>
<p>It turns out this is as far as just sitting down and writing code will take
us. We need to get more serious, and transform this small pile of fragile code
into something we can actually hack confidently and transform without fear of
destroying it.</p>
<p>Therefore, we leave <code>layout</code> intact, show the failing test and move on to
Part 2 of the book, where we will reorganize the code into a coherent
software package and then... we will try again.</p>
<pre><code class="language-python"># lesson11.py
# We add a &quot;separation&quot; constant so you can see the boxes individually
separation = .05


def layout(_boxes):
    &quot;&quot;&quot;Layout boxes along pages.

    Keep in mind that this function modifies the boxes themselves, so
    you should be very careful about trying to call layout() more than once
    on the same boxes.

    Specifically, some spaces will become 0-width and not stretchy.
    &quot;&quot;&quot;

    # Because we modify the box list, we will work on a copy
    boxes = _boxes[:]
    # We start at page 0
    page = 0
    # The 1st box should be placed in the correct page
    previous = boxes.pop(0)
    previous.x = pages[page].x
    previous.y = pages[page].y
    row = []
    while boxes:
        # We take the new 1st box
        box = boxes.pop(0)
        # And put it next to the other
        box.x = previous.x + previous.w + separation
        # At the same vertical location
        box.y = previous.y

        # Handle breaking on newlines
        break_line = False
        # But if it's a newline
        if (box.letter == '\n'):
            break_line = True
            # Newlines take no horizontal space ever
            box.w = 0
            box.stretchy = False

        # Or if it's too far to the right, and is a
        # good place to break the line...
        elif (box.x + box.w) &gt; (
            pages[page].x + pages[page].w
        ) and box.letter in (
            ' ', '\xad'
        ):
            if box.letter == '\xad':
                # Add a visible hyphen in the row
                h_b = hyphenbox()
                h_b.x = previous.x + previous.w + separation
                h_b.y = previous.y
                _boxes.append(h_b)  # So it's drawn
                row.append(h_b)  # So it's justified
            break_line = True
            # We adjust the row
            # Remove all right-margin spaces
            while row[-1].letter == ' ':
                row.pop()
            slack = (pages[page].x + pages[page].w) - (
                row[-1].x + row[-1].w
            )
            # Get a list of all the ones that are stretchy
            stretchies = [b for b in row if b.stretchy]
            if not stretchies:  # Nothing stretches do as before.
                bump = slack / len(row)
                # The 1st box gets 0 bumps, the 2nd gets 1 and so on
                for i, b in enumerate(row):
                    b.x += bump * i
            else:
                bump = slack / len(stretchies)
                # Each stretchy gets wider
                for b in stretchies:
                    b.w += bump
                # And we put each thing next to the previous one
                for j, b in enumerate(row[1:], 1):
                    b.x = row[j - 1].x + row[j - 1].w + separation


        if break_line:
            # We start a new row
            row = []
            # We go all the way left and a little down
            box.x = pages[page].x
            box.y = previous.y + previous.h + separation

        # But if we go too far down
        if box.y + box.h &gt; pages[page].y + pages[page].h:
            # We go to the next page
            page += 1
            # And put the box at the top-left
            box.x = pages[page].x
            box.y = pages[page].y

        # Put the box in the row
        row.append(box)

        # Collapse all left-margin space
        if all(b.letter == ' ' for b in row):
            box.w = 0
            box.stretchy = False
            box.x = pages[page].x

        previous = box


layout(text_boxes)

</code></pre>
<pre><code class="language-python"># lesson11.py
draw_boxes(text_boxes, 'lesson11.svg', (33, 5), hide_boxes=True)

</code></pre>
<p><img src="part1/lesson11.svg" alt="lesson11.svg" /></p>
<hr />
<p>Further references:</p>
<ul>
<li>Full source code for this lesson <a href="lesson11.py.run.html">lesson11.py</a></li>
<li><a href="part1/code/diffs/lesson10_lesson11.html">Difference with code from last lesson</a></li>
</ul>
<a class="header" href="print.html#recapitulation" id="recapitulation"><h1>Recapitulation</h1></a>
<p>If you are here, you have lived through 11 clumsy attempts at teaching you
something. Or rather, to <em>show</em> you something.</p>
<p>What did we get for our trouble?</p>
<ul>
<li>Some ideas about how to lay down text on a page.</li>
<li>A rough implementation of such ideas.</li>
<li>A specific thing our implementation can't do (yet)</li>
<li>An idea of how it <em>could</em> do it.</li>
</ul>
<p>And, the real goal:</p>
<ul>
<li>A process.</li>
</ul>
<p>What do I mean by &quot;a process&quot;? A way to work, to turn an idea into code.
Sure, our process seems to be limited to &quot;write stuff down&quot;, but in truth
it's slightly more than that. Here it is in more detail:</p>
<ol>
<li>Start with a silly version of what you want and make it work.</li>
</ol>
<p><img src="part1/lesson1.svg" alt="lesson1.svg" /></p>
<ol start="2">
<li>Keep a copy of that thing, and think of a way to make it less silly.</li>
</ol>
<p><img src="part1/lesson2.svg" alt="lesson2.svg" /></p>
<ol start="3">
<li>Iterate point 2 until it sort of looks like what you <em>really</em> want, and not
silly. Always keep track of the improvement.</li>
</ol>
<p><img src="part1/lesson6.svg" alt="lesson6.svg" /></p>
<ol start="4">
<li>Try to make it do what you really want, and notice the problems and unstated assumptions.</li>
</ol>
<p><img src="part1/lesson7.svg" alt="lesson7.svg" /></p>
<ol start="5">
<li>Iterate point 4 until it starts doing what you want it to do.</li>
</ol>
<p><img src="part1/lesson7_pride_and_prejudice.svg" alt="lesson7_pride_and_prejudice.svg" /></p>
<ol start="6">
<li>Apply yourself to make it do things <em>well</em></li>
</ol>
<p><img src="part1/lesson10.svg" alt="lesson10.svg" /></p>
<ol start="7">
<li>Iterate point 6 until you reach a point of diminishing returns, where
improving the code is too hard.</li>
</ol>
<p>We are now at <strong>that</strong> point, and the process needs a tweak. We need to
start doing things in a different way. Just hacking it won't cut it.</p>
<p>That is not a small thing. A vast majority of people who try to learn coding
on their own never get this far. And while in the rest of the book we will be
working on ways to make what we have now <em>better</em>, what we have is <em>fine</em>.</p>
<p>For many people this is as far as your coding needs to take you. You can just
take your knowledge of the language syntax, a desire to play with it and a
problem and ride those things into a working solution that will <em>do what you
need</em>.</p>
<p>I am being deadly serious here. It's possible that you can just stop here. In
fact, maybe you should go, grab the problem that has lead you into trying to
learn to code, and just <em>play for a while</em>.</p>
<p>Go, doodle, build something useful. Create a script that automates something
you want. Use the approach I showed you and just build something.</p>
<p>The rest of the book will still be here if you ever need to level up.</p>
<p>And if you are ready to go on, then let's go.</p>
<a class="header" href="print.html#part-2-ducks-in-a-row" id="part-2-ducks-in-a-row"><h1>Part 2: Ducks in a Row</h1></a>
<p>In Part 1 of this book we worked on a text layout engine. That is, code that
knows how and where letters from a text go in a page. It's not a great engine,
it is far from perfect, but it's the one we've got and for the purposes of
this book, I like it.</p>
<p>We built it by experimenting. However, after a while, it got to the point
where things are too complicated to add. We have an idea on how to do the next
step, but I (really, I) am not confident I can do it without throwing away all
the code and starting over.</p>
<p>Which is why, yes, we <strong>will</strong> throw most of that code away. But we will do it
in a very specific, controlled manner, and we will end up with a much better
thing in its place, without ever breaking it.</p>
<p>Welcome to the world of refactoring and testing.</p>
<p>I will show you how to use a tool called <a href="https://docs.pytest.org/en/latest/">pytest</a>
and using it we will learn how to do incremental improvements with confidence
and radical changes without fear. Well, without too much fear.</p>
<a class="header" href="print.html#setup-1" id="setup-1"><h1>Setup</h1></a>
<a class="header" href="print.html#boxes-v012" id="boxes-v012"><h1>BOXES v0.12</h1></a>
<p>What we have right now is not a real program, it's just a fun script. In order
to turn it into a real program we need to figure out what we <strong>want</strong> it to
be. Then we will take our wish and make it happen. Easy, right?</p>
<p>We have the following things:</p>
<ul>
<li>Code to generate text &quot;boxes&quot; representing a given text file.</li>
<li>Code to generate a series of pages.</li>
<li>Code to lay the text boxes in the pages.</li>
<li>Code to draw text boxes and pages in a SVG.</li>
</ul>
<p>How can we combine those assets into a working, functional piece of software?</p>
<p>Because I am <em>old</em> my first idea is to create a command line tool. We can
explore others later, but this one is easy. It takes the name of a text file
as first argument, and the name of a SVG file as second argument and it
creates the second with the contents of the first.</p>
<p>My favorite to do this is using <a href="https://github.com/docopt/docopt">docopt</a>,
where we will describe how the tool works and it turns the documentation into
actual working code. It's serious overkill for what we want now, but we may
grow into it.</p>
<p>We will start with an empty file and then add all the bits of code we have
until it works.</p>
<p>Here's a first draft:</p>
<pre><code class="language-python">&quot;&quot;&quot;
Usage:
    boxes &lt;input&gt; &lt;output&gt;
    boxes --version
&quot;&quot;&quot;

from docopt import docopt


# __name__ is the name of the current module. If it's called as a
# script, it will be '__main__'
if __name__ == '__main__':
    # If we are called as a script, call docopt.
    # __doc__ is that big string at the beginning of the file.
    arguments = docopt(__doc__, version='Boxes 0.12')
    # Print whatever docopt gives us
    print(arguments)
</code></pre>
<p>And here is how that works. If we call it with two arguments, we get the
information in <code>arguments</code>:</p>
<pre><code class="language-sh">$ python boxes.py foo bar

{'--version': False,
 '&lt;input&gt;': 'foo',
 '&lt;output&gt;': 'bar'}
</code></pre>
<p>If we were missing one, then we are using it wrong, and it will complain and
print the help.</p>
<pre><code class="language-sh">$ python boxes.py foo

Usage:
    boxes &lt;input&gt; &lt;output&gt;
    boxes --version
</code></pre>
<p>And if we pass <code>--version</code>?</p>
<pre><code class="language-sh">$ python boxes.py foo

Boxes 0.12
</code></pre>
<p>So, we have a dictionary with input and output as keys. That is handy. All we
need to do is slap our existing code in this script and make it use those
names.</p>
<pre><code class="language-python"># boxes.py
&quot;&quot;&quot;
Usage:
    boxes &lt;input&gt; &lt;output&gt;
    boxes --version
&quot;&quot;&quot;

from fonts import adjust_widths_by_letter
from hyphen import insert_soft_hyphens

import svgwrite
from docopt import docopt


class Box():

    def __init__(self, x=0, y=0, w=1, h=1, stretchy=False, letter='x'):
        &quot;&quot;&quot;Accept arguments to define our box, and store them.&quot;&quot;&quot;
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.stretchy = stretchy
        self.letter = letter

    def __repr__(self):
        return 'Box(%s, %s, %s, %s, &quot;%s&quot;)' % (
            self.x, self.y, self.w, self.y, self.letter
        )


def hyphenbox():
    b = Box(letter='-')
    adjust_widths_by_letter([b])
    return b


def badness(page_width, row):
    &quot;&quot;&quot;Calculate how 'bad' a position to break is.
    
    bigger is worse.
    &quot;&quot;&quot;
    # Yes, this is suboptimal. It's easier to optimize working code
    # than fixing fast code.
    row_width = (row[-1].x + row[-1].w) - row[0].x
    slack = page_width - row_width
    stretchies = [b for b in row if b.stretchy]
    if len(stretchies) &gt; 0:
        stretchies_width = sum(s.w for s in stretchies)
        # More stetchy space is good. More slack is bad.
        badness = slack / stretchies_width
    else:  # Nothing to stretch. Not good.
        badness = 1000
    if slack &lt; 0:
        # Arbitrary fudge factor, negative slack is THIS much worse
        badness *= 2
    return badness


# We add a &quot;separation&quot; constant so you can see the boxes individually
separation = .05


def layout(_boxes, pages):
    &quot;&quot;&quot;Layout boxes along pages.

    Keep in mind that this function modifies the boxes themselves, so
    you should be very careful about trying to call layout() more than once
    on the same boxes.

    Specifically, some spaces will become 0-width and not stretchy.
    &quot;&quot;&quot;

    # Because we modify the box list, we will work on a copy
    boxes = _boxes[:]
    # We start at page 0
    page = 0
    # The 1st box should be placed in the correct page
    previous = boxes.pop(0)
    previous.x = pages[page].x
    previous.y = pages[page].y
    row = []
    while boxes:
        # We take the new 1st box
        box = boxes.pop(0)
        # And put it next to the other
        box.x = previous.x + previous.w + separation
        # At the same vertical location
        box.y = previous.y

        # Handle breaking on newlines
        break_line = False
        # But if it's a newline
        if (box.letter == '\n'):
            break_line = True
            # Newlines take no horizontal space ever
            box.w = 0
            box.stretchy = False

        # Or if it's too far to the right, and is a
        # good place to break the line...
        elif (box.x + box.w) &gt; (
            pages[page].x + pages[page].w
        ) and box.letter in (
            ' ', '\xad'
        ):
            if box.letter == '\xad':
                # Add a visible hyphen in the row
                h_b = hyphenbox()
                h_b.x = previous.x + previous.w + separation
                h_b.y = previous.y
                _boxes.append(h_b)  # So it's drawn
                row.append(h_b)  # So it's justified
            break_line = True
            # We adjust the row
            # Remove all right-margin spaces
            while row[-1].letter == ' ':
                row.pop()
            slack = (pages[page].x + pages[page].w) - (
                row[-1].x + row[-1].w
            )
            # Get a list of all the ones that are stretchy
            stretchies = [b for b in row if b.stretchy]
            if not stretchies:  # Nothing stretches do as before.
                bump = slack / len(row)
                # The 1st box gets 0 bumps, the 2nd gets 1 and so on
                for i, b in enumerate(row):
                    b.x += bump * i
            else:
                bump = slack / len(stretchies)
                # Each stretchy gets wider
                for b in stretchies:
                    b.w += bump
                # And we put each thing next to the previous one
                for j, b in enumerate(row[1:], 1):
                    b.x = row[j - 1].x + row[j - 1].w + separation


        if break_line:
            # We start a new row
            row = []
            # We go all the way left and a little down
            box.x = pages[page].x
            box.y = previous.y + previous.h + separation

        # But if we go too far down
        if box.y + box.h &gt; pages[page].y + pages[page].h:
            # We go to the next page
            page += 1
            # And put the box at the top-left
            box.x = pages[page].x
            box.y = pages[page].y

        # Put the box in the row
        row.append(box)

        # Collapse all left-margin space
        if all(b.letter == ' ' for b in row):
            box.w = 0
            box.stretchy = False
            box.x = pages[page].x

        previous = box


def draw_boxes(boxes, pages, fname, size, hide_boxes=False):
    dwg = svgwrite.Drawing(fname, profile='full', size=size)
    # Draw the pages
    for page in pages:
        dwg.add(
            dwg.rect(
                insert=(page.x, page.y),
                size=(page.w, page.h),
                fill='lightblue',
            )
        )
    # Draw all the boxes
    for box in boxes:
        # The box color depends on its features
        color = 'green' if box.stretchy else 'red'
        # Make the colored boxes optional
        if not hide_boxes:
            dwg.add(
                dwg.rect(
                    insert=(box.x, box.y),
                    size=(box.w, box.h),
                    fill=color,
                )
            )
        # Display the letter in the box
        if box.letter:
            dwg.add(
                dwg.text(
                    box.letter,
                    insert=(box.x, box.y + box.h),
                    font_size=box.h,
                    font_family='Arial',
                )
            )
    dwg.save()


def create_text_boxes(input_file):
    p_and_p = open(input_file).read()
    p_and_p = insert_soft_hyphens(p_and_p)  # Insert invisible hyphens
    text_boxes = []
    for l in p_and_p:
        text_boxes.append(Box(letter=l, stretchy=l == ' '))
    adjust_widths_by_letter(text_boxes)
    return text_boxes


def create_pages():
    # A few pages all the same size
    pages = [Box(i * 35, 0, 30, 50) for i in range(10)]
    return pages


def convert(input, output):
    pages = create_pages()
    text_boxes = create_text_boxes(input)
    layout(text_boxes, pages)
    draw_boxes(text_boxes, pages, output, (90, 50), True)


if __name__ == '__main__':
    arguments = docopt(__doc__, version='Boxes 0')
    convert(input=arguments['&lt;input&gt;'], output=arguments['&lt;output&gt;'])

</code></pre>
<p>And if we run it like this:</p>
<pre><code class="language-sh">$ python boxes.py pride-and-prejudice.txt lesson1.svg
</code></pre>
<p><img src="part2/lesson1.svg" alt="lesson1.svg" /></p>
<a class="header" href="print.html#part-3-wax-on-wax-off" id="part-3-wax-on-wax-off"><h1>Part 3: Wax On, Wax Off</h1></a>
<a class="header" href="print.html#part-4-going-public" id="part-4-going-public"><h1>Part 4: Going Public</h1></a>
<a class="header" href="print.html#code-listings" id="code-listings"><h1>Code Listings</h1></a>
<a class="header" href="print.html#original-code" id="original-code"><h1>Original Code</h1></a>
<p>In <a href="finger_thinking.html">the intro to Part 1</a> I mentioned that I doodle in a thrwaway python file. Well, here is one I did
not throw away, which turned into the seed for the code in this book.</p>
<p>The code has not been improved in any way other than format it
via <a href="https://github.com/ambv/black">black</a>.</p>
<p>It has comments written as &quot;we&quot; because it was meant to be a blog post, and then it grew.</p>
<p>The code in the book is a lightly cleaned up version of this.</p>
<pre><code class="language-python"># original.py
import svgwrite


class Box():

    def __init__(
        self,
        x=0,
        y=0,
        w=1,
        h=1,
        red=False,
        blue=False,
        yellow=False,
        letter=None,
    ):
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.red = red
        self.blue = blue
        self.yellow = yellow
        self.letter = letter

    def __str__(self):
        return self.letter or 'Box'

    def __repr__(self):
        return self.letter or 'Box'


big_box = Box(0, 0, 80, 1000)
pages = [big_box]


def draw_boxes(boxes, with_boxes=True):
    STYLES = &quot;&quot;&quot;
    .red { fill: red;}
    .green { fill: green;}
    .blue {fill: blue;}
    .yellow {fill: yellow;}
    .bigbox {fill: cyan; }
    &quot;&quot;&quot;
    dwg = svgwrite.Drawing(
        'test.svg',
        profile='full',
        size=('%d' % big_box.w, '%d' % big_box.w),
    )
    dwg.defs.add(dwg.style(STYLES))
    for bb in pages:
        dwg.add(
            dwg.rect(
                insert=(bb.x, bb.y), size=(bb.w, bb.h), class_='bigbox'
            )
        )
    for box in boxes:
        if with_boxes:
            if box.red:
                dwg.add(
                    dwg.rect(
                        insert=(box.x, box.y),
                        size=(box.w, box.h),
                        class_='red',
                    )
                )
            elif box.blue:
                dwg.add(
                    dwg.rect(
                        insert=(box.x, box.y),
                        size=(box.w, box.h),
                        class_='blue',
                    )
                )
            elif box.yellow:
                dwg.add(
                    dwg.rect(
                        insert=(box.x, box.y),
                        size=(box.w, box.h),
                        class_='yellow',
                    )
                )
            else:
                dwg.add(
                    dwg.rect(
                        insert=(box.x, box.y),
                        size=(box.w, box.h),
                        class_='green',
                    )
                )
        if box.letter:
            dwg.add(
                dwg.text(
                    box.letter,
                    insert=(box.x, box.y + box.h),
                    font_size=box.h,
                    font_family='Arial',
                )
            )
    dwg.save()


# So, how could we layout the many boxes inside the big_box?
many_boxes = [Box(0, 0, 1, 1) for _ in range(5000)]

# Do nothing ...
# They are all in the same place
# draw_boxes(many_boxes)

# Try to lay them out side by side
# They just go too wide
# We add a &quot;separation&quot; constant so you can see the boxes individually
separation = .2


def layout1(boxes):
    for i, box in enumerate(boxes):
        box.x = i * (1 + separation)


# Put each one next to the other until they reach a width,
# then go down. This is a monospaced layout.


def layout2(boxes):
    for i, box in enumerate(boxes[1:]):
        box.x = boxes[i - 1].x + 1 + separation
        box.y = boxes[i - 1].y
        if box.x &gt; big_box.w:
            box.x = 0
            box.y = boxes[i - 1].y + 1.1


# Now, what happens if some boxes are wider than the others?
# layout2 will make them overlap or have wide breaks between them
import random

many_boxes = [
    Box(0, 0, 1 + random.randint(-2, 2) / 10, 1) for _ in range(5000)
]

# So, we use each box's width instead of a fixed width


def layout3(boxes):
    for i, box in enumerate(boxes[1:], 1):
        prev_box = boxes[i - 1]
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        if box.x &gt; big_box.w:
            box.x = 0
            box.y = prev_box.y + 1.1


# layout3(many_boxes)
# But the right side is ragged

# We can, when we break, put the remaining space spread between boxes
# This is a &quot;justified&quot; layout


def layout4(boxes):
    last_break = 0
    for i, box in enumerate(boxes[1:], 1):
        prev_box = boxes[i - 1]
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        if box.x &gt; big_box.w:
            box.x = 0
            box.y = prev_box.y + 1.1
            slack = big_box.w - (prev_box.x + prev_box.w)
            mini_slack = slack / (i - last_break)
            for j, b in enumerate(boxes[last_break:i]):
                b.x += j * mini_slack
            last_break = i


# layout4(many_boxes)

# But what happens if some boxes are red?
for box in many_boxes:
    if random.randint(1, 6) &gt; 5:
        box.red = True
# Well, nothing much, other than they are red

# But what if red means &quot;stretchy&quot; and only those can stretch?


def layout5(boxes):
    last_break = 0
    for i, box in enumerate(boxes[1:], 1):
        prev_box = boxes[i - 1]
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        if box.x &gt; big_box.w:
            box.x = 0
            box.y = prev_box.y + 1.1
            slack = big_box.w - (prev_box.x + prev_box.w)
            row = boxes[last_break:i]
            reds = [b for b in row if b.red]
            # sometimes there is no red in the row. Do nothing.
            if reds:
                mini_slack = slack / len(reds)
                for b in reds:
                    b.w += mini_slack
                for j, b in enumerate(row[1:], 1):
                    b.x = row[j - 1].x + row[j - 1].w + separation
            last_break = i


# But what happens if a few are blue?
for box in many_boxes:
    if random.randint(1, 150) &gt; 149:
        box.blue = True

# Well, nothing much, other than they are blue

# But what if blue means &quot;this row ends here&quot;?


def layout6(boxes):
    last_break = 0
    for i, box in enumerate(boxes[1:], 1):
        prev_box = boxes[i - 1]
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        if prev_box.blue or box.x &gt; big_box.w:
            box.x = 0
            box.y = prev_box.y + 1.1
            slack = big_box.w - (prev_box.x + prev_box.w)
            row = boxes[last_break:i]
            reds = [b for b in row if b.red]
            # sometimes there is no red in the row. Do nothing.
            if reds:
                mini_slack = slack / len(reds)
                for b in reds:
                    b.w += mini_slack
                for j, b in enumerate(row[1:], 1):
                    b.x = row[j - 1].x + row[j - 1].w + separation
            last_break = i


# Some reds get reeeeeeealy stretchy! That is because rows that
# end because of a blue have very few boxes. So maybe we don't stretch those?


def layout7(boxes):
    last_break = 0
    for i, box in enumerate(boxes[1:], 1):
        prev_box = boxes[i - 1]
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        if prev_box.blue or box.x &gt; big_box.w:
            box.x = 0
            box.y = prev_box.y + 1.1
            if not prev_box.blue:
                row = boxes[last_break:i]
                slack = big_box.w - (row[-1].x + row[-1].w)
                reds = [b for b in row if b.red]
                # sometimes there is no red in the row. Do nothing.
                if reds:
                    mini_slack = slack / len(reds)
                    for b in reds:
                        b.w += mini_slack
                    for j, b in enumerate(row[1:], 1):
                        b.x = row[j - 1].x + row[j - 1].w + separation
            last_break = i


# What if we want blue boxes break lines but also separate lines a little?


def layout8(boxes):
    last_break = 0
    for i, box in enumerate(boxes[1:], 1):
        prev_box = boxes[i - 1]
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        if prev_box.blue or box.x &gt; big_box.w:
            box.x = 0
            if prev_box.blue:
                box.y = prev_box.y + 2.1
            else:  # not blue
                box.y = prev_box.y + 1.1
                row = boxes[last_break:i]
                slack = big_box.w - (row[-1].x + row[-1].w)
                reds = [b for b in row if b.red]
                # sometimes there is no red in the row. Do nothing.
                if reds:
                    mini_slack = slack / len(reds)
                    for b in reds:
                        b.w += mini_slack
                    for j, b in enumerate(row[1:], 1):
                        b.x = row[j - 1].x + row[j - 1].w + separation
            last_break = i


# So ... what if each box has a letter or a space inside it?
for box in many_boxes:
    # More than one space so they appear often
    box.letter = random.choice('     abcdefghijklmnopqrstuvwxyz')

# Maybe we should make the box sizes depend on the letter inside it?
# This is complicated, sorry
import harfbuzz as hb
import freetype2 as ft


def adjust_widths_by_letter(boxes):
    buf = hb.Buffer.create()
    buf.add_str(''.join(b.letter for b in boxes))
    buf.guess_segment_properties()
    font_lib = ft.get_default_lib()
    face = font_lib.find_face('Arial')
    face.set_char_size(size=1, resolution=64)
    font = hb.Font.ft_create(face)
    hb.shape(font, buf)
    # at this point buf.glyph_positions has all the data we need
    for box, position in zip(boxes, buf.glyph_positions):
        box.w = position.x_advance


adjust_widths_by_letter(many_boxes)
# layout8(many_boxes)

# There is all that space between letters we added when they were boxes. Let's remove it.

separation = 0
layout8(many_boxes)

# How about we get the letters from a text instead of randomly?
p_and_p = open('pride-and-prejudice.txt').read()
text_boxes = []
for l in p_and_p:
    text_boxes.append(Box(letter=l))
adjust_widths_by_letter(text_boxes)
# layout8(text_boxes)
# Oh, it's all green now, and it's all one thing after another. We should make newlines blue!

for b in text_boxes:
    if b.letter == '\n':
        b.blue = True
# layout8(text_boxes)

# Better, but newlines should not really take any space should they?


def add_blue(boxes):
    for b in boxes:
        if b.letter == '\n':
            b.blue = True
            b.w = 0


add_blue(text_boxes)
# layout8(text_boxes)

# Our big_box is very wide now, that is why we have long lines. Let's make it narrower
big_box = Box(0, 0, 30, 1000)
# layout8(text_boxes)

# But our right side is ragged again! We should make spaces red.


def add_red(boxes):
    for b in boxes:
        if b.letter == ' ':
            b.red = True


add_red(text_boxes)
# layout8(text_boxes)

# The second paragraph of Chapter 1 shows a red space as first thing in the row, and that looks bad!
# So, when the 1st letter in a row is a space, let's make it take no width and not stretch


def layout9(boxes):
    last_break = 0
    for i, box in enumerate(boxes[1:], 1):
        prev_box = boxes[i - 1]
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        if prev_box.blue or box.x &gt; big_box.w:
            box.x = 0
            if box.red:
                box.w = 0
            if prev_box.blue:
                box.y = prev_box.y + 2.1
            else:  # not blue
                box.y = prev_box.y + 1.1
                row = boxes[last_break:i]
                slack = big_box.w - (row[-1].x + row[-1].w)
                # If the 1st thing is a red, that one doesn't stretch
                reds = [b for b in row[1:] if b.red]
                # sometimes there is no red in the row. Do nothing.
                if reds:
                    mini_slack = slack / len(reds)
                    for b in reds:
                        b.w += mini_slack
                    for j, b in enumerate(row[1:], 1):
                        b.x = row[j - 1].x + row[j - 1].w + separation
            last_break = i


# Just for fun, let's draw it without the colored boxes
# layout9(text_boxes)
# draw_boxes(text_boxes, False)

# XXX layout9 rewritten using pop(), need to backport this version


def layout10(_boxes):
    boxes = _boxes[:]  # Work on a copy
    prev_box = boxes.pop(0)
    row = [prev_box]
    while (boxes):
        box = boxes.pop(0)
        row.append(box)
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        if prev_box.blue or box.x &gt; big_box.w:
            box.x = 0
            row.pop()  # our box will go in the next row
            if box.red:
                box.w = 0
            if prev_box.blue:
                box.y = prev_box.y + 2.1

            else:  # not blue
                box.y = prev_box.y + 1.1
                slack = big_box.w - (row[-1].x + row[-1].w)
                # If the 1st thing is a red, that one doesn't stretch
                reds = [b for b in row[1:] if b.red]
                # sometimes there is no red in the row. Do nothing.
                if reds:
                    mini_slack = slack / len(reds)
                    for b in reds:
                        b.w += mini_slack
                    for j, b in enumerate(row[1:], 1):
                        b.x = row[j - 1].x + row[j - 1].w + separation
            row = [box]
        prev_box = box


# layout10(text_boxes)

# Looks good, except that the words are broken wrong. You can't break good like: g
# ood!

# What if we only break on spaces?


def layout11(_boxes):
    boxes = _boxes[:]  # Work on a copy
    prev_box = boxes.pop(0)
    row = [prev_box]
    while (boxes):
        box = boxes.pop(0)
        row.append(box)
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        if prev_box.blue or (box.x &gt; big_box.w and box.red):
            row.pop()  # our box will go in the next row
            box.x = 0
            if box.red:
                box.w = 0
            if prev_box.blue:
                box.y = prev_box.y + 2.1

            else:  # not blue
                box.y = prev_box.y + 1.1
                slack = big_box.w - (row[-1].x + row[-1].w)
                # If the 1st thing is a red, that one doesn't stretch
                reds = [b for b in row[1:] if b.red]
                # sometimes there is no red in the row. Do nothing.
                if reds:
                    mini_slack = slack / len(reds)
                    for b in reds:
                        b.w += mini_slack
                    for j, b in enumerate(row[1:], 1):
                        b.x = row[j - 1].x + row[j - 1].w + separation
            row = [box]
        prev_box = box


# layout11(text_boxes)

# That actually ... worked? Except that when we need to fit something wider than
# big_box because we did not break the row, the slack is NEGATIVE and words get
# smushed together!

# What we actually need is hyphenation.
# We can use pyphen to insert soft-hyphen characters wherever words can break.
# And we can mark those positions yellow.

import pyphen

hyphenator = pyphen.Pyphen(
    lang='en_GB'
)  # These things are language dependent

p_and_p = open('pride-and-prejudice.txt').readlines()
for i, l in enumerate(p_and_p):
    words = l.split(' ')
    p_and_p[i] = ' '.join(
        hyphenator.inserted(w, '\u00AD') for w in words
    )
p_and_p = ''.join(p_and_p)

text_boxes = []
for l in p_and_p:
    text_boxes.append(Box(letter=l))


# This makes the characters '\u00AD' (soft-hyphen) yellow.


def add_yellow(boxes):
    for b in boxes:
        if b.letter == '\u00AD':
            b.yellow = True


add_blue(text_boxes)
add_red(text_boxes)
add_yellow(text_boxes)
adjust_widths_by_letter(text_boxes)

# And create a new layout function that also breaks on yellow boxes.


def layout12(_boxes):
    boxes = _boxes[:]  # Work on a copy
    prev_box = boxes.pop(0)
    row = [prev_box]
    while (boxes):
        box = boxes.pop(0)
        row.append(box)
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        if prev_box.blue or (
            box.x &gt; big_box.w and (box.red or box.yellow)
        ):
            row.pop()  # our box will go in the next row
            box.x = 0
            if box.red:
                box.w = 0
            if prev_box.blue:
                box.y = prev_box.y + 2.1

            else:  # not blue
                box.y = prev_box.y + 1.1
                slack = big_box.w - (row[-1].x + row[-1].w)
                # If the 1st thing is a red, that one doesn't stretch
                reds = [b for b in row[1:] if b.red]
                # sometimes there is no red in the row. Do nothing.
                if reds:
                    mini_slack = slack / len(reds)
                    for b in reds:
                        b.w += mini_slack
                    for j, b in enumerate(row[1:], 1):
                        b.x = row[j - 1].x + row[j - 1].w + separation
            row = [box]
        prev_box = box


# layout12(text_boxes)

# Better! Since we have more break chances, there is less word-smushing.
# However our typography is wrong, because we are hyphenating but not showing a hyphen!
# So, we need to ADD a box when we hyphenate. That special box is hyphenbox():


def hyphenbox():  # Yes, this is not optimal
    b = Box(letter='-', yellow=True)
    adjust_widths_by_letter([b])
    return b


def layout13(_boxes):
    boxes = _boxes[:]  # Work on a copy
    prev_box = boxes.pop(0)
    row = [prev_box]
    while (boxes):
        box = boxes.pop(0)
        row.append(box)
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        if prev_box.blue or (
            box.x &gt; big_box.w and (box.red or box.yellow)
        ):
            row.pop()  # our box will go in the next row
            if box.yellow:  # We need to insert the hyphen!
                h_b = hyphenbox()
                h_b.x = prev_box.x + prev_box.w + separation
                h_b.y = prev_box.y
                _boxes.append(h_b)  # So it's drawn
                row.append(h_b)  # So it's justified
            box.x = 0
            if box.red:
                box.w = 0
            if prev_box.blue:
                box.y = prev_box.y + 2.1

            else:  # not blue
                box.y = prev_box.y + 1.1
                slack = big_box.w - (row[-1].x + row[-1].w)
                # If the 1st thing is a red, that one doesn't stretch
                reds = [b for b in row[1:] if b.red]
                # sometimes there is no red in the row. Do nothing.
                if reds:
                    mini_slack = slack / len(reds)
                    for b in reds:
                        b.w += mini_slack
                    for j, b in enumerate(row[1:], 1):
                        b.x = row[j - 1].x + row[j - 1].w + separation
            row = [box]
        prev_box = box


# layout13(text_boxes)

# Good. However, we still have smushing. It's usually considered better to make spaces
# between words grow, rather than shrink. So, what we should do is, instead of breaking
# in the 1st yellow/red PAST the break, go back and break in the last BEFORE the break!

# XXX backport simplifications from layout14: separation of blue case


def layout14(_boxes):
    boxes = _boxes[:]  # Work on a copy
    row = [boxes.pop(0)]
    while (boxes):
        prev_box = row[-1]
        box = boxes.pop(0)
        row.append(box)
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        if prev_box.blue:
            box.x = 0
            box.y = prev_box.y + 2.1
            row.pop()
            row = [box]

        elif box.x &gt; big_box.w:
            while not (box.red or box.yellow):  # backtrack onw
                boxes.insert(0, row.pop())
                # tip of row is now box, previous one is prev_box
                box = row[-1]
                prev_box = row[-2]

            row.pop()  # Breaking box goes in next row
            if box.yellow:  # We need to insert the hyphen!
                h_b = hyphenbox()
                h_b.x = prev_box.x + prev_box.w + separation
                h_b.y = prev_box.y
                _boxes.append(h_b)  # So it's drawn
                row.append(h_b)  # So it's justified
            box.x = 0
            box.y = prev_box.y + 1.1
            if box.red:
                box.w = 0
            slack = big_box.w - (row[-1].x + row[-1].w)
            # If the 1st thing is a red, that one doesn't stretch
            reds = [b for b in row[1:] if b.red]
            # sometimes there is no red in the row. Do nothing.
            if reds:
                mini_slack = slack / len(reds)
                for b in reds:
                    b.w += mini_slack
                for j, b in enumerate(row[1:], 1):
                    b.x = row[j - 1].x + row[j - 1].w + separation
            row = [box]


# With a little separation for niceness, the result is not half bad!
separation = 0.05
# layout14(text_boxes)

# So far, our big_box has been very, very tall. What would happen if it were short?
big_box = Box(0, 0, 30, 60)
# layout14(text_boxes)

# Well, that our text flows straight out of the box! And our initial problem was
# &quot;So, how could we layout the many boxes inside the big_box?&quot; !
# That won't do. Clearly, if we have more text than fits in a box, we need more than one
# box. Like pages.

# So, let's make many big boxes.


pages = [Box(0, i * 65, 30, 60) for i in range(50)]

# layout14(text_boxes)

# Of course our layout engine does nothing with those pages. Let's fix that.


def layout15(_boxes):
    boxes = _boxes[:]  # Work on a copy
    row = [boxes.pop(0)]

    # Put the 1st box in the beginning of the 1st page
    page = 0
    row[0].x = pages[page].x
    row[0].y = pages[page].y

    while (boxes):
        prev_box = row[-1]
        box = boxes.pop(0)
        row.append(box)
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        if prev_box.blue:
            box.x = 0
            box.y = prev_box.y + 2.1
            row.pop()
            row = [box]

        elif box.x &gt; pages[page].w:
            while not (box.red or box.yellow):  # backtrack onw
                boxes.insert(0, row.pop())
                # tip of row is now box, previous one is prev_box
                box = row[-1]
                prev_box = row[-2]

            row.pop()  # Breaking box goes in next row
            if box.yellow:  # We need to insert the hyphen!
                h_b = hyphenbox()
                h_b.x = prev_box.x + prev_box.w + separation
                h_b.y = prev_box.y
                _boxes.append(h_b)  # So it's drawn
                row.append(h_b)  # So it's justified
            box.x = 0
            box.y = prev_box.y + 1.1
            if box.red:
                box.w = 0
            slack = pages[page].w - (row[-1].x + row[-1].w)
            # If the 1st thing is a red, that one doesn't stretch
            reds = [b for b in row[1:] if b.red]
            # sometimes there is no red in the row. Do nothing.
            if reds:
                mini_slack = slack / len(reds)
                for b in reds:
                    b.w += mini_slack
                for j, b in enumerate(row[1:], 1):
                    b.x = row[j - 1].x + row[j - 1].w + separation
            row = [box]

        if box.y + box.h &gt; pages[page].y + pages[page].h:
            # We need to go to the next page
            page = page + 1
            box.y = pages[page].y


# layout15(text_boxes)
# And there you go, pagination

# What happens if pages are organized differently?
# Let's put them left-to-right
pages = [Box(i * 35, 0, 30, 60) for i in range(50)]
# layout15(text_boxes)

# Everything is in the same page, because we are resetting x to 0 on line breaks.
# You always need to find your hidden assumptions.


def layout16(_boxes):
    boxes = _boxes[:]  # Work on a copy
    row = [boxes.pop(0)]

    # Put the 1st box in the beginning of the 1st page
    page = 0
    row[0].x = pages[page].x
    row[0].y = pages[page].y

    while (boxes):
        prev_box = row[-1]
        box = boxes.pop(0)
        row.append(box)
        box.x = prev_box.x + prev_box.w + separation
        box.y = prev_box.y
        if prev_box.blue:
            box.x = pages[page].x
            box.y = prev_box.y + 2.1
            row.pop()
            row = [box]

        elif box.x &gt; pages[page].w + pages[page].x:
            while not (box.red or box.yellow):  # backtrack onw
                boxes.insert(0, row.pop())
                # tip of row is now box, previous one is prev_box
                box = row[-1]
                prev_box = row[-2]

            row.pop()  # Breaking box goes in next row
            if box.yellow:  # We need to insert the hyphen!
                h_b = hyphenbox()
                h_b.x = prev_box.x + prev_box.w + separation
                h_b.y = prev_box.y
                _boxes.append(h_b)  # So it's drawn
                row.append(h_b)  # So it's justified
            box.x = pages[page].x
            box.y = prev_box.y + 1.1
            if box.red:
                box.w = 0
            slack = (pages[page].w + pages[page].x) - (
                row[-1].x + row[-1].w
            )
            # If the 1st thing is a red, that one doesn't stretch
            reds = [b for b in row[1:] if b.red]
            # sometimes there is no red in the row. Do nothing.
            if reds:
                mini_slack = slack / len(reds)
                for b in reds:
                    b.w += mini_slack
                for j, b in enumerate(row[1:], 1):
                    b.x = row[j - 1].x + row[j - 1].w + separation
            row = [box]

        # We may need to go to the next page
        if box.y + box.h &gt; pages[page].y + pages[page].h:
            page = page + 1
            # Since the location of a page is arbitrary, both coordinates are reset
            box.y = pages[page].y
            box.x = pages[page].x


# This may even work with oddly-sized pages!
pages = [
    Box(i * 35, 0, 20, 60 + random.randint(-20, 20)) for i in range(50)
]

layout16(text_boxes)
draw_boxes(text_boxes, False)

# This is a good point to STOP. Look at the code, and clean house.

</code></pre>
<a class="header" href="print.html#dependencies" id="dependencies"><h1>Dependencies</h1></a>
<p>(add list of things used in the code with references)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
